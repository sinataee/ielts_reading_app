IELTS Reading App - Full Project Code Snapshot
Generated from current repository files.

====================================================================================================
FILE: .gitignore
====================================================================================================

# Python
__pycache__/
*.pyc

# Virtual environments
venv/
.venv/
env/
ENV/

# Environment and secrets
.env
secrets/*.json

# IDE and OS
.vscode/
.idea/
.DS_Store
Thumbs.db

# Test JSON files only
tests/*.json
*.test.json

====================================================================================================
FILE: CONTRIBUTING.md
====================================================================================================

# Contributing to IELTS Reading Test Application

First off, thank you for considering contributing to the IELTS Reading Test Application! It's people like you that make this tool better for everyone.

## Code of Conduct

This project and everyone participating in it is governed by our Code of Conduct. By participating, you are expected to uphold this code. Please report unacceptable behavior to the project maintainers.

## How Can I Contribute?

### Reporting Bugs

Before creating bug reports, please check the existing issues to avoid duplicates. When you create a bug report, include as many details as possible:

**Bug Report Template:**
```
**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '...'
3. See error

**Expected behavior**
What you expected to happen.

**Screenshots**
If applicable, add screenshots.

**Environment:**
 - OS: [e.g. Windows 10, Ubuntu 22.04]
 - Python Version: [e.g. 3.9.7]
 - Application Version: [e.g. 1.2]

**Additional context**
Any other context about the problem.
```

### Suggesting Enhancements

Enhancement suggestions are tracked as GitHub issues. When creating an enhancement suggestion, include:

- **Use a clear and descriptive title**
- **Provide a detailed description** of the suggested enhancement
- **Explain why this enhancement would be useful**
- **List some examples** of how it would be used

### Pull Requests

1. **Fork the repository** and create your branch from `main`
2. **Make your changes** following our coding standards
3. **Test your changes** thoroughly
4. **Update documentation** if needed
5. **Submit a pull request**

## Development Process

### Setting Up Development Environment

1. Fork and clone the repository:
```bash
git clone https://github.com/yourusername/ielts-reading-app.git
cd ielts-reading-app
```

2. Create a virtual environment (optional but recommended):
```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

3. Install development dependencies:
```bash
pip install -r requirements.txt
```

4. Verify installation:
```bash
python test_installation.py
```

### Coding Standards

#### Python Style Guide

- Follow [PEP 8](https://www.python.org/dev/peps/pep-0008/) style guide
- Use meaningful variable and function names
- Add docstrings to all functions and classes
- Keep functions focused and small (ideally < 50 lines)
- Use type hints where appropriate

#### Example:

```python
def calculate_band_score(correct_count: int, scoring_rules: IELTSScoringRules) -> float:
    """
    Calculate IELTS band score based on correct answer count.
    
    Args:
        correct_count: Number of correct answers
        scoring_rules: IELTS scoring rules object
        
    Returns:
        Band score as a float (0.0 - 9.0)
    """
    if correct_count in scoring_rules.mapping:
        return scoring_rules.mapping[correct_count]
    return 0.0
```

#### GUI Development

- Use consistent spacing and padding
- Follow the existing color scheme
- Ensure UI is responsive
- Test on different screen resolutions
- Add tooltips for complex features

#### File Organization

```
ielts-reading-app/
‚îú‚îÄ‚îÄ main.py              # Keep main launcher simple
‚îú‚îÄ‚îÄ models.py            # All data models here
‚îú‚îÄ‚îÄ content_editor.py    # Content Editor module
‚îú‚îÄ‚îÄ exam_engine.py       # Exam Engine module
‚îú‚îÄ‚îÄ result_engine.py     # Result Engine module
‚îú‚îÄ‚îÄ utils/               # Utility functions (if needed)
‚îî‚îÄ‚îÄ tests/               # Test files
```

### Testing

Before submitting a pull request:

1. **Run the installation test:**
```bash
python test_installation.py
```

2. **Manual testing checklist:**
- [ ] Create a new package
- [ ] Test all 11 question types
- [ ] Take a complete exam
- [ ] View results
- [ ] Export results
- [ ] Open and edit existing package
- [ ] Test on fullscreen mode
- [ ] Test highlighting feature
- [ ] Test table builder
- [ ] Test flowchart builder

3. **Edge cases to test:**
- [ ] Empty fields
- [ ] Maximum question counts (10 per group)
- [ ] Special characters in text
- [ ] Very long paragraphs
- [ ] Very long questions
- [ ] Timer expiration
- [ ] Pause/resume functionality

### Documentation

When adding new features:

1. **Update README_GITHUB.md** with new features
2. **Add to QUESTION_TYPES_GUIDE.md** if adding question types
3. **Update UPDATE_NOTES** with version changes
4. **Add inline comments** for complex logic
5. **Write docstrings** for all new functions

### Commit Messages

Use clear and descriptive commit messages:

```
feat: Add support for image insertion in diagrams
fix: Correct band score calculation for 40 questions
docs: Update installation guide for macOS
style: Format code according to PEP 8
refactor: Simplify question rendering logic
test: Add tests for Type 9 table builder
```

Prefix conventions:
- `feat:` New feature
- `fix:` Bug fix
- `docs:` Documentation changes
- `style:` Code style changes (formatting)
- `refactor:` Code refactoring
- `test:` Adding or updating tests
- `chore:` Maintenance tasks

## Project Structure

### Core Modules

**models.py**
- Data structures and models
- Serialization/deserialization
- Validation logic

**content_editor.py**
- Rich text editing
- Question creation UI
- Table/flowchart builders
- Package management

**exam_engine.py**
- Exam interface
- Timer management
- Highlighting system
- Answer collection
- Visual rendering (tables, flowcharts)

**result_engine.py**
- Answer evaluation
- Score calculation
- Results display
- Statistics generation

### Adding New Features

#### Adding a New Question Type

1. Add to `QuestionType` enum in `models.py`
2. Update `create_answer_input()` in `exam_engine.py`
3. Add input form in `add_question_group()` in `content_editor.py`
4. Update `QUESTION_TYPES_GUIDE.md`
5. Add example in sample package generator

#### Adding New Highlighting Colors

1. Add color to `HighlightToolbar` in `exam_engine.py`
2. Add tag configuration in text widgets
3. Update `_color_to_name()` mapping

#### Adding Export Formats

1. Create new export function in `result_engine.py`
2. Add button in results UI
3. Handle file format conversion
4. Update documentation

## Feature Requests

We track feature requests through GitHub Issues. Before creating a new feature request:

1. **Search existing issues** to avoid duplicates
2. **Be specific** about the feature
3. **Explain the use case**
4. **Consider implementation** complexity

## Questions?

Feel free to create an issue with the label `question` if you need help.

## Recognition

Contributors will be recognized in:
- README.md contributors section
- Release notes
- Project documentation

Thank you for contributing! üéâ

====================================================================================================
FILE: INSTALL_GUIDE.md
====================================================================================================

# IELTS Reading Test Application
# Complete Installation and Usage Guide

## INSTALLATION INSTRUCTIONS

### Prerequisites
- Python 3.7 or higher
- tkinter (usually comes with Python)

### Step 1: Verify Python Installation
```bash
python --version
# or
python3 --version
```

You should see Python 3.7 or higher.

### Step 2: Install tkinter (if needed)

**On Ubuntu/Debian Linux:**
```bash
sudo apt-get update
sudo apt-get install python3-tk
```

**On Fedora/RedHat Linux:**
```bash
sudo dnf install python3-tkinter
```

**On macOS:**
tkinter should be included with Python. If not:
```bash
brew install python-tk
```

**On Windows:**
tkinter is included with Python installer. If missing:
- Download Python from python.org
- Run installer
- Check "tcl/tk and IDLE" option
- Complete installation

### Step 3: Verify Installation
```bash
cd ielts_reading_app
python test_installation.py
```

This will check all components and report any issues.

### Step 4: Run the Application
```bash
python main.py
```

## APPLICATION STRUCTURE

```
ielts_reading_app/
‚îÇ
‚îú‚îÄ‚îÄ main.py                    # Main application launcher
‚îú‚îÄ‚îÄ models.py                  # Data models and structures
‚îú‚îÄ‚îÄ content_editor.py          # Content creation module
‚îú‚îÄ‚îÄ exam_engine.py             # Test-taking module
‚îú‚îÄ‚îÄ result_engine.py           # Results and scoring module
‚îú‚îÄ‚îÄ test_installation.py       # Installation verification
‚îú‚îÄ‚îÄ requirements.txt           # Python dependencies
‚îú‚îÄ‚îÄ README.md                  # Main documentation
‚îú‚îÄ‚îÄ QUICK_START.txt           # Quick start guide
‚îî‚îÄ‚îÄ INSTALL_GUIDE.md          # This file
```

## USAGE WORKFLOWS

### Workflow 1: Create and Take Your First Test

1. **Launch Application**
   ```bash
   python main.py
   ```

2. **Create Sample Package** (Recommended for first time)
   - Click "Create Sample Package"
   - Save as "my_first_test.json"
   - Close the save dialog

3. **Take the Test**
   - Click "Take Exam"
   - Select "my_first_test.json"
   - Click "Start Exam"
   - Answer the questions
   - Click "End Exam" when done

4. **Review Results**
   - View your band score
   - Check detailed feedback
   - Review incorrect answers

### Workflow 2: Create Custom Reading Package

1. **Open Content Editor**
   - Launch main.py
   - Click "Content Editor"

2. **Add Reading Content**
   - Enter explanation text
   - Enter passage title
   - Click "Add Paragraph" multiple times
   - Fill in paragraph titles and bodies
   - Use formatting toolbar (Bold, Italic, Headers)
   - Click "Save Reading Content"

3. **Add Question Groups**
   - Click "Add Question Group"
   - Enter group explanation
   - Select question type from dropdown
   - Add at least 2 questions (max 10)
   - Enter answers
   - For matching questions, add additional inputs
   - Click "Save Question Group"
   - Repeat for multiple question groups

4. **Save Package**
   - Go to File > Save Package
   - Choose location and filename
   - Click Save

### Workflow 3: Taking a Timed Exam

1. **Load Package**
   - Launch exam_engine.py or use main menu
   - Select package file

2. **Exam Interface**
   - Left side: Reading passage
   - Right side: Questions
   - Top: Timer and controls

3. **During Exam**
   - Read passage carefully
   - Highlight important text (select text, choose color)
   - Answer questions in any order
   - Use Pause button if needed
   - Watch the timer

4. **Submit**
   - Click "End Exam" to submit early
   - Or wait for timer to expire
   - Automatic submission when time is up

### Workflow 4: Analyzing Results

1. **Summary View**
   - Band score (0-9)
   - Correct/Incorrect/Unanswered counts
   - Quick performance overview

2. **Detailed Results Tab**
   - Question-by-question breakdown
   - Your answer vs correct answer
   - Marked as correct/incorrect

3. **Incorrect Answers Tab**
   - Focus on mistakes only
   - Review what you got wrong
   - Learn from errors

4. **Statistics Tab**
   - Performance by question type
   - Accuracy percentages
   - Overall statistics

5. **Export Results**
   - Click "Export Results"
   - Save as JSON file
   - Track progress over time

## QUESTION TYPES REFERENCE

### Type 1: Multiple Choice
- Select A, B, C, or D
- Radio button interface

### Type 2: True/False/Not Given
- Verify factual statements
- Three-option selector

### Type 3: Yes/No/Not Given
- Author's opinion/view
- Three-option selector

### Type 4: Matching Information
- Match info to paragraphs
- Dropdown selector

### Type 5: Matching Headings
- Match headings to paragraphs
- Dropdown selector

### Type 6: Matching Features
- Match features to options
- Dropdown selector

### Type 7: Matching Sentence Endings
- Complete sentences
- Dropdown selector

### Type 8: Sentence Completion
- Fill in missing words
- Text input field

### Type 9: Summary/Table/Flow-chart Completion
- Complete diagrams/tables
- Multiple text fields

### Type 10: Diagram Label Completion
- Label diagram parts
- Text fields

### Type 11: Short Answer Questions
- Brief text answers
- Text input field
- Word limit specified

## KEYBOARD SHORTCUTS

### Content Editor
- **Ctrl+N**: New Package
- **Ctrl+O**: Open Package
- **Ctrl+S**: Save Package
- **Ctrl+B**: Bold (when text selected)
- **Ctrl+I**: Italic (when text selected)

### Exam Engine
- **Space**: Pause/Resume (when Start clicked)
- **Enter**: Submit answer (in text fields)
- **Tab**: Move to next field
- **Ctrl+A**: Select all (in text fields)

### General
- **Alt+F4** (Windows/Linux): Close window
- **Cmd+Q** (macOS): Quit application
- **Esc**: Close dialogs

## TIPS AND BEST PRACTICES

### Content Creation Tips
1. Write clear, unambiguous questions
2. Make answers specific and exact
3. Use 2-4 paragraphs for passages
4. Mix different question types
5. Test your package before distributing

### Test-Taking Tips
1. Read instructions carefully
2. Skim passage first, then read in detail
3. Highlight keywords and key information
4. Manage your time (20 minutes per passage)
5. Answer all questions (no penalty for guessing)
6. Check answers before submitting

### Study Tips
1. Practice regularly (3-4 times per week)
2. Review incorrect answers
3. Focus on weak question types
4. Time yourself strictly
5. Track your band score progress

## TROUBLESHOOTING

### Problem: "tkinter not found"
**Solution:**
```bash
# Ubuntu/Debian
sudo apt-get install python3-tk

# Fedora
sudo dnf install python3-tkinter

# macOS
brew install python-tk

# Windows - Reinstall Python with tcl/tk
```

### Problem: Application freezes during exam
**Solution:**
1. Close application completely
2. Restart application
3. Load package again
4. If persists, check system resources

### Problem: Can't load package file
**Solution:**
1. Verify file is .json format
2. Check file isn't corrupted
3. Try creating new sample package
4. Validate JSON syntax online

### Problem: Answers not being recorded
**Solution:**
1. Make sure exam is started (click "Start Exam")
2. Click inside answer fields
3. For dropdown, select an option
4. For text fields, type and press Enter

### Problem: Timer not starting
**Solution:**
1. Click "Start Exam" button
2. Check if Python has threading support
3. Restart application

### Problem: Wrong band score
**Solution:**
1. Verify you're using Academic scoring
2. Check answer accuracy
3. Review evaluation algorithm
4. Count correct answers manually

## FILE FORMATS

### Package File (.json)
```json
{
  "package_id": "unique-identifier",
  "reading_content": {
    "explanation": "Instructions for candidates",
    "title": "Passage Title",
    "paragraphs": [
      {
        "title": "Section Title",
        "body": "Paragraph text content..."
      }
    ]
  },
  "question_groups": [
    {
      "explanation": "Question instructions",
      "type": "Multiple Choice",
      "questions": [
        {
          "question_id": "q1",
          "text": "Question text?",
          "answer": "Correct answer"
        }
      ],
      "additional_inputs": {
        "input_type": "Type4",
        "data": {"infoList": ["Item 1", "Item 2"]}
      }
    }
  ],
  "created_at": "2025-02-10T10:30:00"
}
```

### Results File (.json)
```json
{
  "correct_count": 25,
  "incorrect_count": 8,
  "unanswered_count": 7,
  "total_questions": 40,
  "band_score": 6.5,
  "per_question_feedback": [
    {
      "question_id": "q1",
      "is_correct": true,
      "correct_answer": "answer",
      "user_answer": "answer"
    }
  ]
}
```

## ADVANCED FEATURES

### Rich Text Formatting
- Bold: Select text, click B button
- Italic: Select text, click I button
- Font size: Select size from dropdown
- Headers: H1 (large), H2 (medium)
- Alignment: Left, Center

### Text Highlighting
- Yellow: General highlighting
- Green: Key facts
- Blue: Definitions
- Pink: Important names/dates
- Remove: Clear highlighting

### Answer Normalization
- Case-insensitive comparison
- Leading/trailing spaces removed
- Common punctuation ignored
- "Answer" matches "answer" matches "ANSWER"

## PERFORMANCE OPTIMIZATION

### For Large Packages (50+ questions)
1. Use pagination if needed
2. Close other applications
3. Ensure adequate RAM (2GB+)
4. Use SSD for faster file loading

### For Smooth Experience
1. Close unnecessary programs
2. Use modern Python version (3.9+)
3. Keep packages under 20 question groups
4. Limit paragraph length to 500 words

## SCORING SYSTEM

### IELTS Academic Reading Band Scores
- 39-40 correct ‚Üí Band 9.0 (Expert)
- 37-38 correct ‚Üí Band 8.5 (Very Good)
- 35-36 correct ‚Üí Band 8.0 (Very Good)
- 33-34 correct ‚Üí Band 7.5 (Good)
- 30-32 correct ‚Üí Band 7.0 (Good)
- 27-29 correct ‚Üí Band 6.5 (Competent)
- 23-26 correct ‚Üí Band 6.0 (Competent)
- 19-22 correct ‚Üí Band 5.5 (Modest)
- 15-18 correct ‚Üí Band 5.0 (Modest)
- 13-14 correct ‚Üí Band 4.5 (Limited)
- 10-12 correct ‚Üí Band 4.0 (Limited)

## GETTING HELP

### Resources
1. README.md - Comprehensive documentation
2. QUICK_START.txt - Quick reference
3. models.py - Data structure documentation
4. Test packages - Example content

### Community Support
- Review module docstrings
- Check error messages
- Run test_installation.py
- Examine sample packages

## LICENSE AND CREDITS

This is an educational application for IELTS test preparation.
Based on Cambridge IELTS test format specifications.

Developed following software engineering best practices:
- Modular architecture
- Clear separation of concerns
- Comprehensive documentation
- Thorough testing

## NEXT STEPS

1. Complete test_installation.py successfully
2. Create sample package
3. Take practice test
4. Review results
5. Create custom packages
6. Practice regularly
7. Track progress

Good luck with your IELTS preparation! üéì

====================================================================================================
FILE: LICENSE
====================================================================================================

MIT License

Copyright (c) 2025 IELTS Reading Test Application

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

====================================================================================================
FILE: PROJECT_SUMMARY.md
====================================================================================================

# IELTS Reading Test Application - Project Summary

## Overview
A complete Python application for creating, administering, and scoring IELTS Academic Reading tests, following the architecture described in your UML diagrams and module specifications.

## Delivered Components

### Core Application Files
1. **main.py** - Application launcher with menu interface
2. **models.py** - Complete data models (ReadingPackage, QuestionGroup, Question, etc.)
3. **content_editor.py** - Content creation module with rich text editing
4. **exam_engine.py** - Test-taking module with timer and highlighting
5. **result_engine.py** - Results display with band scoring

### Documentation Files
1. **README.md** - Comprehensive documentation (7KB)
2. **INSTALL_GUIDE.md** - Detailed installation and usage guide (12KB)
3. **QUICK_START.txt** - Quick reference guide (5KB)
4. **QUESTION_TYPES_GUIDE.md** - Detailed input requirements for all 11 question types (NEW)
5. **requirements.txt** - Python dependencies (minimal)

### Testing & Utilities
1. **test_installation.py** - Installation verification script

## Recent Updates (v1.1)

### Enhanced Question Input System
- **Type 1 (Multiple Choice)**: Now properly collects question text, all choice options (A, B, C, D), and answer letter
- **Type 2 & 3**: Dropdown selector for TRUE/FALSE/NOT GIVEN and YES/NO/NOT GIVEN
- **Types 4-7 (Matching)**: Dynamic additional input fields for lists, dropdown populated with options during exam
- **Type 9 (Summary/Table/Flow-chart)**: Text area for summary/table content
- **Type 10 (Diagram)**: Field for diagram description or image path
- **Type 11 (Short Answer)**: Text field with proper validation

### Content Editor Improvements
- **Dynamic Question Forms**: Form fields change automatically based on selected question type
- **Additional Inputs Section**: Automatically updates to show relevant inputs for matching questions (Types 4-7, 9-10)
- **Multiple Choice Support**: Dedicated text area for entering all choice options
- **Better Validation**: Ensures all required fields are filled before saving

### Exam Engine Enhancements
- **Multiple Choice Display**: Properly extracts and displays all choice options as radio buttons
- **Dropdown Population**: For matching questions, dropdown menus are automatically populated with options from additional inputs
- **Better Question Formatting**: Separates question text from choices for cleaner display

## Architecture Implementation

### Based on Your UML Diagrams

#### Class Diagram ‚úì
- ReadingPackage
- ReadingContent with Paragraphs
- QuestionGroup with 11 QuestionTypes
- Question with answers
- AnswerRecord
- EvaluationResult with FeedbackItem
- IELTSScoringRules with band mapping

#### Component Diagram ‚úì
- UserInterface (Tkinter GUI)
- ContentEditor (content_editor.py)
- PackageStorage (JSON serialization)
- ExamEngine (exam_engine.py)
- ResultEngine (result_engine.py)
- ScoringService (IELTSScoringRules)
- SessionManager (answer tracking)

#### Sequence Diagram ‚úì
- User authentication flow (simplified)
- Package creation and storage
- Exam session management
- Answer collection
- Result calculation
- Score mapping

### Module Specifications Implementation

#### Content Editor Module ‚úì
- Rich text editor with toolbar (bold, italic, headers, alignment)
- Reading content creation (explanation, title, paragraphs)
- Question group management (2-10 questions per group)
- All 11 question types supported
- Additional inputs for matching questions
- Package validation before saving
- JSON export/import

#### Exam Engine Module ‚úì
- Split-screen layout (reading left, questions right)
- 60-minute countdown timer with pause/resume
- Text highlighting system (4 colors)
- Answer input types for all question types:
  * Multiple choice (radio buttons)
  * True/False/Not Given (3-option selector)
  * Yes/No/Not Given (3-option selector)
  * Matching types (dropdown selectors)
  * Text completion (text fields)
  * Short answer (text fields)
- Real-time answer recording
- Automatic submission on timeout
- Session management

#### Result Engine Module ‚úì
- Answer evaluation with normalization
- Correct/Incorrect/Unanswered counting
- IELTS Academic band score calculation (0-9 scale)
- Detailed feedback per question
- Three result views:
  * Summary with cards
  * Detailed question-by-question
  * Incorrect answers only
  * Statistics by question type
- JSON export capability
- Band score interpretation

## Key Features

### Content Creation
- WYSIWYG rich text editing
- Multiple paragraph support
- 11 IELTS question types
- Package validation
- Save/load functionality
- Sample package generator

### Test Taking
- Professional exam interface
- Timed tests (60 minutes)
- Text highlighting (4 colors)
- Answer tracking
- Pause/resume capability
- Progress monitoring

### Results & Scoring
- Official IELTS band score (0-9)
- Comprehensive feedback
- Performance statistics
- Question type analysis
- Result export
- Visual summary cards

## Technical Specifications

### Technology Stack
- **Language**: Python 3.7+
- **GUI Framework**: Tkinter
- **Data Format**: JSON
- **Architecture**: MVC-inspired modular design

### Dependencies
- Python standard library only
- No external packages required
- tkinter (included with Python)

### File Structure
```
ielts_reading_app/
‚îú‚îÄ‚îÄ main.py                 (9.7 KB)
‚îú‚îÄ‚îÄ models.py               (8.4 KB)
‚îú‚îÄ‚îÄ content_editor.py       (19.3 KB)
‚îú‚îÄ‚îÄ exam_engine.py          (19.2 KB)
‚îú‚îÄ‚îÄ result_engine.py        (17.8 KB)
‚îú‚îÄ‚îÄ test_installation.py    (5.9 KB)
‚îú‚îÄ‚îÄ README.md               (7.2 KB)
‚îú‚îÄ‚îÄ INSTALL_GUIDE.md        (12.1 KB)
‚îú‚îÄ‚îÄ QUICK_START.txt         (4.7 KB)
‚îî‚îÄ‚îÄ requirements.txt        (0.6 KB)
```

**Total Code**: ~80 KB
**Total Documentation**: ~25 KB
**Total Lines of Code**: ~2,500+

## Supported Question Types

1. Multiple Choice (TYPE1)
2. True/False/Not Given (TYPE2)
3. Yes/No/Not Given (TYPE3)
4. Matching Information (TYPE4)
5. Matching Headings (TYPE5)
6. Matching Features (TYPE6)
7. Matching Sentence Endings (TYPE7)
8. Sentence Completion (TYPE8)
9. Summary/Table/Flow-chart Completion (TYPE9)
10. Diagram Label Completion (TYPE10)
11. Short Answer Questions (TYPE11)

## How to Use

### Quick Start
```bash
cd ielts_reading_app
python main.py
```

### Create First Test
1. Click "Create Sample Package"
2. Save the file
3. Click "Take Exam"
4. Select saved file
5. Complete the test
6. View results

### Create Custom Package
1. Click "Content Editor"
2. Add reading content
3. Add question groups
4. Save package
5. Use in Exam Engine

## Testing

### Installation Verification
```bash
python test_installation.py
```

### Manual Testing
1. Create sample package ‚úì
2. Open package in editor ‚úì
3. Take exam ‚úì
4. View results ‚úì
5. Export results ‚úì

## IELTS Band Score System

The application uses official IELTS Academic Reading conversion:

| Correct | Band | Level |
|---------|------|-------|
| 39-40   | 9.0  | Expert |
| 37-38   | 8.5  | Very Good |
| 35-36   | 8.0  | Very Good |
| 33-34   | 7.5  | Good |
| 30-32   | 7.0  | Good |
| 27-29   | 6.5  | Competent |
| 23-26   | 6.0  | Competent |
| 19-22   | 5.5  | Modest |
| 15-18   | 5.0  | Modest |
| 13-14   | 4.5  | Limited |
| 10-12   | 4.0  | Limited |

## Advantages

### For Test Creators
- Easy content creation
- Rich text formatting
- Flexible question types
- Package reusability
- Validation built-in

### For Test Takers
- Realistic exam environment
- Proper timing
- Text highlighting
- Instant results
- Detailed feedback

### For Both
- Cross-platform (Windows, Mac, Linux)
- No installation complexity
- Lightweight application
- Professional interface
- JSON data portability

## Future Enhancement Possibilities

1. **Multi-user Support**
   - User authentication
   - Progress tracking
   - Statistics dashboard

2. **Database Integration**
   - SQLite for storage
   - Query capabilities
   - Historical data

3. **Advanced Features**
   - Audio for listening section
   - Image upload for diagrams
   - PDF export
   - Cloud sync

4. **Analytics**
   - Performance trends
   - Weak area identification
   - Study recommendations

5. **Content Library**
   - Pre-made test packages
   - Community sharing
   - Official practice tests

## Code Quality

### Best Practices
- Type hints throughout
- Comprehensive docstrings
- Error handling
- Input validation
- Clean separation of concerns

### Architecture
- Modular design
- MVC-inspired structure
- Reusable components
- Clear interfaces
- Extensible framework

### Documentation
- README with examples
- Installation guide
- Quick start guide
- Inline comments
- Function documentation

## Compliance

### IELTS Standards
- Follows Cambridge IELTS format
- Accurate band scoring
- Standard question types
- Proper timing (60 minutes)
- Official scoring rules

### Software Standards
- Python PEP 8 style
- Clear naming conventions
- Proper error messages
- User-friendly interface
- Intuitive workflows

## Deliverables Checklist

‚úì Complete Python application
‚úì All three modules implemented
‚úì Data models matching UML diagrams
‚úì GUI interface (Tkinter)
‚úì Timer functionality
‚úì Highlighting system
‚úì Answer recording
‚úì Band score calculation
‚úì Results display
‚úì Package save/load
‚úì Comprehensive documentation
‚úì Installation guide
‚úì Quick start guide
‚úì Test verification script
‚úì Sample package generator
‚úì Error handling
‚úì Input validation
‚úì Professional UI design

## Summary

This is a complete, production-ready IELTS Reading Test application that:

1. **Implements all specified modules** from your documents
2. **Follows the UML architecture** exactly
3. **Supports all 11 question types** from IELTS
4. **Provides professional interface** for all users
5. **Includes comprehensive documentation** for easy use
6. **Uses standard Python libraries** for maximum compatibility
7. **Handles the complete workflow** from creation to results

The application is ready to use immediately and can be extended with additional features as needed.

## Contact & Support

For issues or questions:
1. Review README.md
2. Check INSTALL_GUIDE.md
3. Run test_installation.py
4. Examine module docstrings

---

**Project Status**: COMPLETE ‚úì
**Ready for Deployment**: YES ‚úì
**Documentation**: COMPREHENSIVE ‚úì
**Testing**: VERIFIED ‚úì

---

Thank you for using the IELTS Reading Test Application!

====================================================================================================
FILE: QUESTION_TYPES_GUIDE.md
====================================================================================================

# IELTS Question Types - Input Requirements Guide

This document explains exactly what inputs are required for each of the 11 IELTS Reading question types.

---

## Type 1: Multiple Choice

**Required Inputs:**
1. Question text
2. Multiple choice options (A, B, C, D or more)
3. Correct answer (the letter of the correct choice)

**Format in Content Editor:**
- **Question Text**: Enter the question followed by choices on new lines
- **Choices**: Format as "A. Choice text", "B. Choice text", etc.
- **Answer**: Enter only the letter (A, B, C, or D)

**Example:**
```
Question: Who invented the telephone?
A. Thomas Edison
B. Alexander Graham Bell
C. Nikola Tesla
D. Benjamin Franklin

Answer: B
```

**In the Application:**
```
Question Text: 
Who invented the telephone?
A. Thomas Edison
B. Alexander Graham Bell
C. Nikola Tesla
D. Benjamin Franklin

Correct Answer: B
```

---

## Type 2: Identifying Information (True/False/Not Given)

**Required Inputs:**
1. Statement/question text
2. Correct answer (TRUE, FALSE, or NOT GIVEN)

**Format:**
- **Question Text**: Enter the statement to verify
- **Answer**: Select from dropdown (TRUE, FALSE, NOT GIVEN)

**Example:**
```
Statement: The bicycle was invented in the 18th century.
Answer: FALSE
```

**Usage Notes:**
- TRUE: Statement agrees with the passage
- FALSE: Statement contradicts the passage
- NOT GIVEN: Information is not mentioned in the passage

---

## Type 3: Identifying Writer's Views/Claims (Yes/No/Not Given)

**Required Inputs:**
1. Statement about writer's opinion/claim
2. Correct answer (YES, NO, or NOT GIVEN)

**Format:**
- **Question Text**: Enter the statement about the writer's view
- **Answer**: Select from dropdown (YES, NO, NOT GIVEN)

**Example:**
```
Statement: The author believes electric cars will replace gasoline vehicles.
Answer: YES
```

**Usage Notes:**
- YES: Statement agrees with the writer's views
- NO: Statement contradicts the writer's views
- NOT GIVEN: Writer's view on this is not stated

---

## Type 4: Matching Information

**Required Inputs:**
1. Question text (what to match)
2. List of information items (options to choose from)
3. Correct answer (reference to the information item)

**Format:**
- **Question Text**: "Which paragraph/section mentions X?"
- **List of Information**: Provided in "Additional Inputs" section
  ```
  A. First option
  B. Second option
  C. Third option
  ```
- **Answer**: The letter of the correct option (A, B, C, etc.)

**Example:**
```
Additional Inputs (List of Information):
A. Early Developments
B. The Penny-Farthing Era
C. The Safety Bicycle

Question: Which paragraph describes the invention of pneumatic tires?
Answer: C
```

---

## Type 5: Matching Headings

**Required Inputs:**
1. Question text (usually "Choose the correct heading for paragraph X")
2. List of headings to choose from
3. Correct answer (the heading identifier)

**Format:**
- **Question Text**: "Choose the correct heading for paragraph 3"
- **List of Headings**: Provided in "Additional Inputs"
  ```
  i. The benefits of exercise
  ii. Different types of sports
  iii. Health risks of inactivity
  iv. Popular fitness trends
  ```
- **Answer**: The roman numeral or letter (i, ii, iii, etc.)

**Example:**
```
Additional Inputs (List of Headings):
i. Early bicycle designs
ii. Modern cycling technology
iii. The impact on transportation
iv. Safety improvements

Question: Choose the correct heading for paragraph 2
Answer: i
```

---

## Type 6: Matching Features

**Required Inputs:**
1. Question text (statement or description to match)
2. List of features/people/dates to match to
3. Correct answer (the feature identifier)

**Format:**
- **Question Text**: Statement or description
- **List of Features**: Provided in "Additional Inputs"
  ```
  A. Albert Einstein
  B. Isaac Newton
  C. Marie Curie
  D. Stephen Hawking
  ```
- **Answer**: The letter of the correct feature

**Example:**
```
Additional Inputs (List of Features):
A. The running machine
B. The penny-farthing
C. The safety bicycle
D. Modern bicycles

Question: Which bicycle type had a large front wheel and small rear wheel?
Answer: B
```

---

## Type 7: Matching Sentence Endings

**Required Inputs:**
1. Question text (incomplete sentence/statement)
2. List of possible sentence endings
3. Correct answer (the ending identifier)

**Format:**
- **Question Text**: Incomplete sentence
- **List of Endings**: Provided in "Additional Inputs"
  ```
  A. improved safety significantly.
  B. made bicycles more expensive.
  C. reduced the speed of travel.
  D. increased the weight of the bicycle.
  ```
- **Answer**: The letter of the correct ending

**Example:**
```
Additional Inputs (List of Sentence Endings):
A. was made entirely of wood.
B. had equal-sized wheels.
C. could reach high speeds.
D. was difficult to mount.

Question: The penny-farthing
Answer: C
```

---

## Type 8: Sentence Completion

**Required Inputs:**
1. Incomplete sentence with a blank
2. Correct answer (the word(s) that complete the sentence)

**Format:**
- **Question Text**: "The bicycle was invented by _______."
- **Answer**: "Karl von Drais" (or the specific word(s) from the passage)

**Example:**
```
Question: The running machine was made entirely of _______.
Answer: wood
```

**Usage Notes:**
- Usually specifies word limit (e.g., "NO MORE THAN THREE WORDS")
- Answer must be taken from the passage
- Spelling must be exact

---

## Type 9: Summary/Note/Table/Flow-chart Completion

**Required Inputs:**
1. Question text (identifies the blank to fill)
2. Summary/table/flow-chart structure (provided as additional input)
3. Correct answer (word(s) to fill the blank)

**Format:**
- **Additional Input**: The summary, table, or flow-chart with [BLANK] markers or numbers
- **Question Text**: Reference to which blank (e.g., "Question 15" corresponding to blank 15)
- **Answer**: The word(s) that fill the blank

**Example:**
```
Additional Inputs (Summary):
The bicycle has evolved significantly over time. The first bicycle, called the 
[1]_______, was invented by Karl von Drais in 1817. Later, the [2]_______ 
became popular but was dangerous to ride. The modern safety bicycle has 
[3]_______ wheels.

Question 1: Complete blank 1
Answer: running machine

Question 2: Complete blank 2
Answer: penny-farthing

Question 3: Complete blank 3
Answer: equal-sized
```

**For Tables:**
```
Additional Inputs (Table):
| Bicycle Type    | Year | Key Feature    |
|----------------|------|----------------|
| Running machine| 1817 | [1]_______     |
| Penny-farthing | 1870 | Large front wheel |
| Safety bicycle | [2]_______ | Equal wheels |

Question 1: Answer: made of wood
Question 2: Answer: 1890
```

---

## Type 10: Diagram Label Completion

**Required Inputs:**
1. Question text (which part of diagram to label)
2. Diagram image or description (provided as additional input)
3. Correct answer (the label text)

**Format:**
- **Additional Input**: Diagram description or image path
  ```
  Diagram showing parts of a bicycle:
  - Part A: [blank]
  - Part B: [blank]
  - Part C: Pedal
  - Part D: [blank]
  ```
- **Question Text**: "Label part A" or "What is part A?"
- **Answer**: "Handlebars" (or the correct label)

**Example:**
```
Additional Inputs (Diagram):
[Diagram of early bicycle showing:
1. Front wheel assembly
2. [blank] - the part riders push with their feet
3. Wooden frame
4. [blank] - the person operating the device]

Question 1: What is part 2?
Answer: ground

Question 2: What is part 4?
Answer: rider
```

---

## Type 11: Short Answer Questions

**Required Inputs:**
1. Question text (direct question)
2. Correct answer (brief answer, usually 1-3 words)

**Format:**
- **Question Text**: Direct question
- **Answer**: Brief text answer from the passage

**Example:**
```
Question: Who invented pneumatic tires?
Answer: John Boyd Dunlop

Question: What material was the running machine made from?
Answer: wood

Question: When was the safety bicycle introduced?
Answer: 1890s
```

**Usage Notes:**
- Usually has word limit (e.g., "NO MORE THAN THREE WORDS")
- Must use words from the passage
- No articles (a, an, the) required unless in the passage

---

## Summary Table

| Type | Question Input | Additional Input | Answer Input |
|------|---------------|------------------|--------------|
| 1    | Question + Choices | None | Letter (A, B, C, D) |
| 2    | Statement | None | TRUE/FALSE/NOT GIVEN |
| 3    | Statement | None | YES/NO/NOT GIVEN |
| 4    | Question | Info List | Letter/Number |
| 5    | Question | Heading List | Roman numeral |
| 6    | Statement | Feature List | Letter |
| 7    | Incomplete sentence | Ending List | Letter |
| 8    | Incomplete sentence | None | Word(s) |
| 9    | Blank reference | Summary/Table/Chart | Word(s) |
| 10   | Label reference | Diagram | Label text |
| 11   | Direct question | None | Short answer |

---

## Tips for Content Creators

1. **Be Specific**: Make questions clear and unambiguous
2. **Use Passage Words**: Answers should come directly from the reading passage
3. **Follow Format**: Stick to the standard IELTS format for each type
4. **Word Limits**: For types 8, 9, 10, 11, specify word limits in instructions
5. **Clear Options**: For matching types (4-7), ensure options are distinct
6. **Test First**: Create and test your package before distributing

---

## Common Mistakes to Avoid

‚ùå **Type 1**: Forgetting to include all choice options
‚ùå **Type 1**: Using full text as answer instead of just the letter
‚ùå **Types 2-3**: Using subjective answers not supported by passage
‚ùå **Types 4-7**: Not providing the list of options in Additional Inputs
‚ùå **Types 4-7**: Using descriptive answer instead of the reference letter
‚ùå **Type 9**: Not clearly marking blanks in the summary/table
‚ùå **Type 10**: Not providing diagram description
‚ùå **Type 11**: Exceeding word limits

---

## Application Workflow

### Creating Questions:

1. **Select Question Type** from dropdown
2. **Additional Inputs section updates** automatically based on type
3. **Fill in Additional Inputs** if required (Types 4-7, 9-10)
4. **Add Questions** (minimum 2, maximum 10 per group)
5. **For each question**:
   - Enter question text (including choices for Type 1)
   - Enter correct answer in appropriate format
6. **Save Question Group**

### Taking Exam:

- Type 1: Radio buttons with full choice text displayed
- Types 2-3: Three radio button options
- Types 4-7: Dropdown menu with options from Additional Inputs
- Types 8, 11: Text entry field
- Type 9: Multiple text fields for each blank
- Type 10: Text fields for each diagram label

---

## Examples from Sample Package

See the "Create Sample Package" feature in the application for a working example that includes:
- Type 1: Multiple Choice with 4 options
- Type 2: True/False/Not Given statements
- Type 4: Matching Information with paragraph references
- Type 11: Short answer questions

---

**Last Updated**: February 2025
**Application Version**: 1.0

====================================================================================================
FILE: QUICK_START.txt
====================================================================================================

"""
QUICK START GUIDE
=================

Welcome to the IELTS Reading Test Application!

STEP 1: VERIFY INSTALLATION
----------------------------
Open terminal/command prompt and run:
    python --version

You should see Python 3.7 or higher.

Test tkinter:
    python -m tkinter

A small window should appear. Close it to continue.


STEP 2: LAUNCH THE APPLICATION
-------------------------------
Navigate to the application directory:
    cd ielts_reading_app

Run the main launcher:
    python main.py

You should see a window with three options:
- Content Editor
- Take Exam  
- Create Sample Package


STEP 3: CREATE YOUR FIRST PACKAGE
----------------------------------
Option A: Use the Sample Package (Recommended for first-time users)
1. Click "Create Sample Package"
2. Choose where to save it (e.g., "my_first_test.json")
3. Click Save

Option B: Create Your Own Package
1. Click "Content Editor"
2. Enter explanation text (e.g., "You should spend about 20 minutes...")
3. Enter title (e.g., "Climate Change and Global Warming")
4. Click "Add Paragraph" and fill in paragraph details
5. Click "Save Reading Content"
6. Click "Add Question Group"
7. Fill in questions and answers (minimum 2 questions)
8. Click "Save Question Group"
9. Go to File > Save Package


STEP 4: TAKE A TEST
-------------------
1. Click "Take Exam" from the main menu
2. Select your saved package file (.json)
3. Read the passage on the left side
4. Click "Start Exam" to begin the timer
5. Answer questions on the right side
6. Optional: Highlight important text by selecting it
7. Click "End Exam" when finished


STEP 5: VIEW YOUR RESULTS
--------------------------
Results appear automatically after exam submission:
- Band Score (0-9)
- Correct/Incorrect/Unanswered counts
- Detailed feedback tab
- Incorrect answers review
- Performance statistics


TROUBLESHOOTING
---------------
Problem: "tkinter not found"
Solution: Install tkinter:
    - Ubuntu/Debian: sudo apt-get install python3-tk
    - Fedora: sudo dnf install python3-tkinter
    - macOS: tkinter should be included with Python
    - Windows: Reinstall Python with tcl/tk option checked

Problem: Application freezes
Solution: 
    - Close and restart the application
    - Check that no other process is blocking Python

Problem: Can't load package file
Solution:
    - Verify the file is a .json file
    - Try creating a new sample package
    - Check file permissions


KEYBOARD SHORTCUTS (when applicable)
-------------------------------------
Content Editor:
- Ctrl+S: Save (via File menu)
- Ctrl+O: Open (via File menu)

Exam Engine:
- Select text + click color: Highlight
- Alt+F4 / Cmd+Q: Exit application


TIPS FOR BEST EXPERIENCE
-------------------------
1. Create packages in the Content Editor first
2. Start with the sample package to understand the format
3. Use the pause button if you need a break during exam
4. Review incorrect answers to learn from mistakes
5. Export results to track your progress over time


SUPPORTED QUESTION TYPES
-------------------------
‚úì Multiple Choice (A, B, C, D)
‚úì True/False/Not Given
‚úì Yes/No/Not Given
‚úì Matching Information
‚úì Matching Headings
‚úì Matching Features
‚úì Matching Sentence Endings
‚úì Sentence Completion
‚úì Summary/Table/Flow-chart Completion
‚úì Diagram Label Completion
‚úì Short Answer Questions


FILE LOCATIONS
--------------
Application files:
    main.py              - Main launcher
    content_editor.py    - Content creation
    exam_engine.py       - Test taking
    result_engine.py     - Results display
    models.py            - Data structures

Your created files:
    *.json               - Reading packages
    *_results.json       - Exported results


GETTING HELP
------------
1. Read the README.md file for detailed documentation
2. Check the module docstrings in each Python file
3. Review the sample package structure
4. Examine the models.py file for data formats


ADVANCED FEATURES
-----------------
1. Rich Text Formatting
   - Bold, italic, different sizes
   - Headers (H1, H2)
   - Left and center alignment

2. Multiple Question Groups
   - Mix different question types in one test
   - Each group can have 2-10 questions

3. Additional Inputs
   - For matching questions, provide lists
   - For diagram questions, reference images
   - Stored in JSON format

4. Answer Validation
   - Case-insensitive comparison
   - Whitespace trimming
   - Punctuation removal


NEXT STEPS
----------
1. Create 3-4 practice packages
2. Take tests and review results
3. Track your band score improvement
4. Focus on question types where you score lower
5. Practice time management (20 minutes per passage)


Happy studying and good luck with your IELTS preparation! üéì
"""

====================================================================================================
FILE: README.md
====================================================================================================

# IELTS Reading Test Application

[![Python Version](https://img.shields.io/badge/python-3.7%2B-blue.svg)](https://www.python.org/downloads/)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)
[![Platform](https://img.shields.io/badge/platform-Windows%20%7C%20Linux%20%7C%20macOS-lightgrey.svg)](https://github.com/yourusername/ielts-reading-app)

A comprehensive desktop application for creating, taking, and scoring IELTS Academic Reading tests. Built with Python and Tkinter.

![IELTS Reading App Screenshot](docs/screenshot.png)

## üåü Features

### Content Editor
- üìù Rich text editing with formatting (bold, italic, headers, alignment)
- üìÑ Create reading passages with multiple paragraphs
- ‚ùì Support for all 11 IELTS question types
- üìä Visual table builder for Type 9 questions
- üîÑ Graphical flow-chart builder
- üíæ Save and load reading packages as JSON files
- ‚úÖ Automatic validation (2-10 questions per group)

### Exam Engine
- üñ•Ô∏è Fullscreen exam interface
- ‚è±Ô∏è 60-minute countdown timer with pause/resume
- üé® Text highlighting system (4 colors)
- üìã Professional table and flow-chart rendering
- üí° Real-time answer recording
- üîí Automatic submission when time expires

### Result Engine
- üéØ IELTS band score calculation (0-9 scale)
- üìä Comprehensive result display
- ‚úÖ Question-by-question feedback
- üìà Performance statistics by question type
- üíæ Export results to JSON

## üìã Question Types Supported

1. ‚úÖ Multiple Choice
2. ‚úÖ True/False/Not Given
3. ‚úÖ Yes/No/Not Given
4. ‚úÖ Matching Information
5. ‚úÖ Matching Headings
6. ‚úÖ Matching Features
7. ‚úÖ Matching Sentence Endings
8. ‚úÖ Sentence Completion
9. ‚úÖ Summary/Table/Flow-chart Completion (with visual builders)
10. ‚úÖ Diagram Label Completion
11. ‚úÖ Short Answer Questions

## üöÄ Quick Start

### Prerequisites

- Python 3.7 or higher
- tkinter (usually included with Python)

### Installation

1. **Clone the repository**
   ```bash
   git clone https://github.com/yourusername/ielts-reading-app.git
   cd ielts-reading-app
   ```

2. **Verify installation**
   ```bash
   python test_installation.py
   ```

3. **Run the application**
   ```bash
   python main.py
   ```

### First Steps

1. Click **"Create Sample Package"** to generate an example test
2. Click **"Take Exam"** and select the sample package
3. Click **"Start Exam"** and complete the test
4. View your results with detailed feedback

## üìñ Usage

### Creating a Test Package

1. Launch the application: `python main.py`
2. Click **"Content Editor"**
3. Add reading content (title, paragraphs)
4. Add question groups:
   - Select question type
   - Enter questions and answers
   - For Type 9, use visual table/flowchart builders
5. Save package: File ‚Üí Save Package

### Taking a Test

1. Click **"Take Exam"**
2. Select a package file (.json)
3. Click **"Start Exam"**
4. Use highlighting tools to mark important text
5. Answer all questions
6. Click **"End Exam"** or wait for timer

### Viewing Results

Results display automatically showing:
- Band score (0-9)
- Correct/Incorrect/Unanswered counts
- Detailed feedback
- Performance by question type
- Option to export results

## üìö Documentation

- [Installation Guide](INSTALL_GUIDE.md) - Detailed setup instructions
- [Quick Start Guide](QUICK_START.txt) - Fast reference
- [Question Types Guide](QUESTION_TYPES_GUIDE.md) - Input requirements for each type
- [Update Notes](UPDATE_NOTES_v1.2.md) - Version history and changes

## üèóÔ∏è Architecture

```
ielts-reading-app/
‚îú‚îÄ‚îÄ main.py                    # Application launcher
‚îú‚îÄ‚îÄ models.py                  # Data models
‚îú‚îÄ‚îÄ content_editor.py          # Content creation module
‚îú‚îÄ‚îÄ exam_engine.py             # Test-taking module
‚îú‚îÄ‚îÄ result_engine.py           # Results and scoring
‚îú‚îÄ‚îÄ test_installation.py       # Installation verification
‚îú‚îÄ‚îÄ requirements.txt           # Dependencies
‚îî‚îÄ‚îÄ docs/                      # Documentation
```

### Key Components

- **Models**: Data structures (ReadingPackage, QuestionGroup, Question, etc.)
- **Content Editor**: Rich text editing, question creation, table/flowchart builders
- **Exam Engine**: Fullscreen interface, timer, highlighting, rendering
- **Result Engine**: Scoring, feedback, statistics, export

## üé® Screenshots

### Content Editor
![Content Editor](docs/content-editor.png)

### Exam Interface
![Exam Interface](docs/exam-interface.png)

### Results Display
![Results](docs/results.png)

## üîß Technical Details

### Built With

- **Python 3.7+** - Programming language
- **Tkinter** - GUI framework
- **JSON** - Data storage format

### IELTS Scoring System

The application uses official IELTS Academic Reading band score conversion:

| Correct Answers | Band Score |
|----------------|------------|
| 39-40          | 9.0        |
| 37-38          | 8.5        |
| 35-36          | 8.0        |
| 33-34          | 7.5        |
| 30-32          | 7.0        |
| 27-29          | 6.5        |
| 23-26          | 6.0        |

## üêõ Troubleshooting

### tkinter not found

**Ubuntu/Debian:**
```bash
sudo apt-get install python3-tk
```

**Fedora:**
```bash
sudo dnf install python3-tkinter
```

**macOS:**
```bash
brew install python-tk
```

**Windows:**
Reinstall Python with tcl/tk option checked

### Application won't start fullscreen

This is normal on some window managers. The app will open in a maximized window instead.

## ü§ù Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## üìù License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## üôè Acknowledgments

- Based on Cambridge IELTS test format specifications
- Designed for IELTS test preparation
- Built following software engineering best practices

## üìß Contact

Project Link: [https://github.com/yourusername/ielts-reading-app](https://github.com/yourusername/ielts-reading-app)

## üó∫Ô∏è Roadmap

- [ ] User authentication system
- [ ] Database storage for packages
- [ ] Progress tracking across tests
- [ ] PDF export
- [ ] Listening section support
- [ ] Writing task modules
- [ ] Mobile version

## üìä Version History

### v1.2 (Current)
- Enhanced Type 9 with visual table/flowchart builders
- Fullscreen exam interface
- Improved text highlighting in tables and flowcharts
- Better visual display of complex content

### v1.1
- Fixed question type input requirements
- Added comprehensive question types guide
- Improved multiple choice display
- Enhanced matching question dropdowns

### v1.0
- Initial release
- All 11 question types supported
- Complete exam workflow
- IELTS band scoring

---

**Made with ‚ù§Ô∏è for IELTS test preparation**

====================================================================================================
FILE: README_LOCAL.md
====================================================================================================

# IELTS Reading Test Application

A comprehensive Python application for creating, taking, and scoring IELTS Academic Reading tests.

## Overview

This application consists of three main modules that follow the architecture specified in the UML diagrams:

1. **Content Editor Module** - Create and edit IELTS reading packages
2. **Exam Engine Module** - Take reading tests with timing and scoring
3. **Result Engine Module** - View detailed results and band scores

## Features

### Content Editor
- Rich text editing with formatting (bold, italic, headers, alignment)
- Create reading passages with multiple paragraphs
- Add question groups (11 different IELTS question types supported)
- Save and load reading packages as JSON files
- Validate question counts (2-10 questions per group)

### Exam Engine
- Split-screen interface (reading passage on left, questions on right)
- 60-minute countdown timer with pause/resume
- Text highlighting system (4 colors)
- Support for all IELTS question types:
  - Type 1: Multiple Choice
  - Type 2: True/False/Not Given
  - Type 3: Yes/No/Not Given
  - Type 4-7: Matching types (Information, Headings, Features, Sentence Endings)
  - Type 8: Sentence Completion
  - Type 9: Summary/Table/Flow-chart Completion
  - Type 10: Diagram Label Completion
  - Type 11: Short Answer Questions
- Real-time answer recording
- Automatic submission when time expires

### Result Engine
- Comprehensive result display with band score (0-9)
- Summary cards showing:
  - Band score with interpretation
  - Correct answers
  - Incorrect answers
  - Unanswered questions
  - Total questions
- Three result tabs:
  - Detailed Results: Question-by-question breakdown
  - Incorrect Answers: Focus on mistakes
  - Statistics: Performance by question type
- Export results to JSON

## Installation

### Requirements
- Python 3.7 or higher
- tkinter (usually included with Python)

### Setup
```bash
# Clone or download the application
cd ielts_reading_app

# Run the application
python main.py
```

## Usage

### 1. Creating a Reading Package

1. Launch the application: `python main.py`
2. Click "Content Editor"
3. Add reading content:
   - Enter explanation (e.g., "You should spend about 20 minutes...")
   - Enter title
   - Add paragraphs with titles and bodies
   - Click "Save Reading Content"
4. Add question groups:
   - Click "Add Question Group"
   - Enter explanation
   - Select question type
   - Add questions (minimum 2, maximum 10)
   - Add answers
   - Optionally add additional inputs (for matching questions)
   - Click "Save Question Group"
5. Save the package: File > Save Package

### 2. Taking a Test

1. Launch the application: `python main.py`
2. Click "Take Exam"
3. Select a reading package file (.json)
4. Click "Start Exam" to begin the timer
5. Read the passage (left side) and answer questions (right side)
6. Use highlighting tools to mark important text:
   - Select text to show highlight toolbar
   - Choose a color or remove highlight
7. Click "End Exam" when finished or let the timer expire

### 3. Viewing Results

Results are displayed automatically after exam submission showing:
- Band score (0-9 scale)
- Number of correct/incorrect/unanswered questions
- Detailed question-by-question feedback
- Performance statistics by question type
- Option to export results

### 4. Creating a Sample Package

1. Launch the application: `python main.py`
2. Click "Create Sample Package"
3. Choose where to save the sample file
4. Use this package to test the Exam Engine

## Architecture

### Data Models (models.py)
- `ReadingPackage`: Complete test package
- `ReadingContent`: Passage content with paragraphs
- `QuestionGroup`: Group of related questions
- `Question`: Individual question with answer
- `AnswerRecord`: User's answer to a question
- `EvaluationResult`: Complete test results
- `IELTSScoringRules`: Band score mapping

### Module Structure

```
ielts_reading_app/
‚îú‚îÄ‚îÄ main.py                 # Application launcher
‚îú‚îÄ‚îÄ models.py               # Data models
‚îú‚îÄ‚îÄ content_editor.py       # Content Editor module
‚îú‚îÄ‚îÄ exam_engine.py          # Exam Engine module
‚îú‚îÄ‚îÄ result_engine.py        # Result Engine module
‚îî‚îÄ‚îÄ README.md              # This file
```

## IELTS Band Score System

The application uses the official IELTS Academic Reading band score conversion:

| Correct Answers | Band Score |
|----------------|------------|
| 39-40          | 9.0        |
| 37-38          | 8.5        |
| 35-36          | 8.0        |
| 33-34          | 7.5        |
| 30-32          | 7.0        |
| 27-29          | 6.5        |
| 23-26          | 6.0        |
| 19-22          | 5.5        |
| 15-18          | 5.0        |
| 13-14          | 4.5        |
| 10-12          | 4.0        |
| 8-9            | 3.5        |
| 6-7            | 3.0        |
| 4-5            | 2.5        |
| 3              | 2.0        |
| 2              | 1.0        |
| 0-1            | 0.0        |

## Question Types Supported

The application supports all 11 IELTS Reading question types. For detailed input requirements for each type, see **QUESTION_TYPES_GUIDE.md**.

1. **Multiple Choice** - Select from options A, B, C, D
2. **True/False/Not Given** - Verify statements against the passage
3. **Yes/No/Not Given** - Author's opinion verification
4. **Matching Information** - Match information to paragraphs
5. **Matching Headings** - Match headings to paragraphs
6. **Matching Features** - Match features to options
7. **Matching Sentence Endings** - Complete sentences
8. **Sentence Completion** - Fill in missing words
9. **Summary/Table/Flow-chart Completion** - Complete diagrams
10. **Diagram Label Completion** - Label diagrams
11. **Short Answer Questions** - Brief text answers

## File Format

Reading packages are stored as JSON files with the following structure:

```json
{
  "package_id": "unique-id",
  "reading_content": {
    "explanation": "Instructions...",
    "title": "Passage Title",
    "paragraphs": [
      {
        "title": "Paragraph Title",
        "body": "Paragraph text..."
      }
    ]
  },
  "question_groups": [
    {
      "explanation": "Question instructions...",
      "type": "Multiple Choice",
      "questions": [
        {
          "question_id": "unique-question-id",
          "text": "Question text?",
          "answer": "correct answer"
        }
      ]
    }
  ]
}
```

## Troubleshooting

### Issue: Application won't start
- Ensure Python 3.7+ is installed
- Check that tkinter is available: `python -m tkinter`

### Issue: Can't load package
- Verify the JSON file is valid
- Check that the file follows the correct structure
- Try creating a new sample package

### Issue: Timer not working
- The timer runs in a separate thread
- Ensure your Python installation supports threading

## Future Enhancements

Potential improvements for future versions:
- User authentication system
- Database storage for packages and results
- Progress tracking across multiple tests
- More detailed analytics and reporting
- Export to PDF
- Audio for listening section
- Writing task modules
- Speaking task recording

## License

This is an educational application for IELTS test preparation.

## Credits

Developed based on Cambridge IELTS test format specifications.

====================================================================================================
FILE: REPOSITORY_SETUP_GUIDE.md
====================================================================================================

# GitHub Repository Setup Guide
## For: https://github.com/sinataee/ielts_reading_app

## ‚úÖ Repository Verification Checklist

Visit your repository and check these items:

### 1. Repository Basics
- [ ] Repository name: `ielts_reading_app` ‚úì
- [ ] Visibility: Public (recommended) or Private
- [ ] Description set
- [ ] Topics/tags added
- [ ] README.md displays on main page
- [ ] License visible (MIT)

### 2. File Structure
Your repository should show these files:
```
ielts_reading_app/
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ README.md (this should be the GitHub version)
‚îú‚îÄ‚îÄ CONTRIBUTING.md
‚îú‚îÄ‚îÄ INSTALL_GUIDE.md
‚îú‚îÄ‚îÄ QUICK_START.txt
‚îú‚îÄ‚îÄ QUESTION_TYPES_GUIDE.md
‚îú‚îÄ‚îÄ UPDATE_NOTES_v1.2.md
‚îú‚îÄ‚îÄ PROJECT_SUMMARY.md
‚îú‚îÄ‚îÄ GITHUB_DEPLOYMENT.md
‚îú‚îÄ‚îÄ GIT_QUICK_REF.md
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ models.py
‚îú‚îÄ‚îÄ content_editor.py
‚îú‚îÄ‚îÄ exam_engine.py
‚îú‚îÄ‚îÄ result_engine.py
‚îú‚îÄ‚îÄ test_installation.py
‚îî‚îÄ‚îÄ requirements.txt
```

### 3. README Display
- [ ] Title shows correctly
- [ ] Badges display (Python version, license)
- [ ] Features section is readable
- [ ] Installation instructions are clear
- [ ] Screenshots section exists (add images later)

## üé® Recommended Repository Settings

### About Section (Top Right)
Click the ‚öôÔ∏è gear icon next to "About" and set:

**Description:**
```
Comprehensive IELTS Academic Reading test preparation application with visual table/flowchart builders, fullscreen exam interface, and automated band scoring
```

**Website:** (optional)
```
https://github.com/sinataee/ielts_reading_app
```

**Topics:** (Add these tags)
```
ielts
reading-test
education
python
tkinter
test-preparation
exam-preparation
language-learning
ielts-preparation
desktop-application
```

### Repository Features
Go to Settings ‚Üí Features and enable:
- ‚úÖ **Issues** - For bug reports and feature requests
- ‚úÖ **Discussions** - For community questions
- ‚¨ú **Wikis** - Optional, for extended documentation
- ‚¨ú **Projects** - Optional, for roadmap

## üìù Immediate Actions

### 1. Add Repository Description
```bash
# If you want to add via command line
git remote set-url origin https://github.com/sinataee/ielts_reading_app.git
```

Or through GitHub web:
1. Go to https://github.com/sinataee/ielts_reading_app
2. Click ‚öôÔ∏è next to "About"
3. Add description and topics
4. Click "Save changes"

### 2. Create First Release

1. Go to: https://github.com/sinataee/ielts_reading_app/releases
2. Click "Create a new release"
3. Fill in:

**Tag version:**
```
v1.2.0
```

**Release title:**
```
Version 1.2.0 - Visual Tables and Flowcharts
```

**Description:**
```markdown
## üéâ First Release - IELTS Reading Test Application v1.2

### Features
- ‚úÖ Complete IELTS Reading test creation and administration
- ‚úÖ Support for all 11 IELTS question types
- ‚úÖ Visual table builder for Type 9 questions
- ‚úÖ Graphical flow-chart builder
- ‚úÖ Fullscreen exam interface
- ‚úÖ Text highlighting system (4 colors)
- ‚úÖ Automatic IELTS band scoring (0-9 scale)
- ‚úÖ Comprehensive results with detailed feedback

### What's Included
- Content Editor with rich text formatting
- Exam Engine with 60-minute timer
- Result Engine with performance statistics
- Sample package generator
- Complete documentation

### Installation
```bash
git clone https://github.com/sinataee/ielts_reading_app.git
cd ielts_reading_app
python test_installation.py
python main.py
```

### Requirements
- Python 3.7+
- tkinter (included with Python)

### Documentation
- [Installation Guide](INSTALL_GUIDE.md)
- [Quick Start](QUICK_START.txt)
- [Question Types Guide](QUESTION_TYPES_GUIDE.md)

**Download the code or clone the repository to get started!**
```

4. Click "Publish release"

### 3. Create Issue Templates

Create a folder structure:
```
.github/
  ISSUE_TEMPLATE/
    bug_report.md
    feature_request.md
```

I can create these files for you if needed!

### 4. Add README Badges

Your README should have these at the top:

```markdown
[![Python Version](https://img.shields.io/badge/python-3.7%2B-blue.svg)](https://www.python.org/downloads/)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)
[![GitHub release](https://img.shields.io/github/v/release/sinataee/ielts_reading_app)](https://github.com/sinataee/ielts_reading_app/releases)
[![GitHub stars](https://img.shields.io/github/stars/sinataee/ielts_reading_app)](https://github.com/sinataee/ielts_reading_app/stargazers)
```

## üñºÔ∏è Adding Screenshots

To make your README more attractive, add screenshots:

### 1. Take Screenshots
Take screenshots of:
- Main launcher window
- Content Editor interface
- Exam interface (showing table/flowchart)
- Results display

### 2. Create docs Folder
```bash
mkdir docs
# Add your screenshots to this folder
```

### 3. Upload to Repository
```bash
git add docs/
git commit -m "docs: Add screenshots"
git push
```

### 4. Reference in README
```markdown
## Screenshots

### Content Editor
![Content Editor](docs/content-editor.png)

### Exam Interface
![Exam Interface](docs/exam-interface.png)

### Results Display
![Results](docs/results.png)
```

## üîß Advanced Setup (Optional)

### GitHub Actions for Testing

Create `.github/workflows/test.yml`:

```yaml
name: Test Installation

on: [push, pull_request]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        python-version: [3.7, 3.8, 3.9, '3.10', '3.11']

    steps:
    - uses: actions/checkout@v3
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    - name: Run installation test
      run: python test_installation.py
```

### Code of Conduct

Create `CODE_OF_CONDUCT.md`:

```markdown
# Code of Conduct

## Our Pledge
We pledge to make participation in our project a harassment-free experience for everyone.

## Our Standards
- Using welcoming and inclusive language
- Being respectful of differing viewpoints
- Gracefully accepting constructive criticism
- Focusing on what is best for the community

## Enforcement
Instances of abusive behavior may be reported to the project maintainers.
```

## üìä Repository Statistics

Once set up, your repository will show:
- Number of stars ‚≠ê
- Number of forks üç¥
- Number of watchers üëÄ
- Number of issues üêõ
- Number of pull requests üîÄ

## üéØ Making Your Repository Popular

### 1. Share on Social Media
- Twitter/X with hashtags: #IELTS #Python #OpenSource
- Reddit: r/IELTS, r/Python, r/LearnProgramming
- LinkedIn: Share as a project

### 2. Add to Lists
- Awesome Python lists
- IELTS resources lists
- Education software collections

### 3. Write Blog Post
Write about your project on:
- Medium
- Dev.to
- Hashnode

### 4. Create Demo Video
- Record a walkthrough
- Upload to YouTube
- Add link to README

## ‚úÖ Final Checklist

Before announcing your repository:

- [ ] All code pushed successfully
- [ ] README displays correctly
- [ ] Description and topics added
- [ ] First release created (v1.2.0)
- [ ] LICENSE file visible
- [ ] Contributing guidelines clear
- [ ] Issue templates created (optional)
- [ ] Screenshots added (optional)
- [ ] Demo video created (optional)

## üîó Important URLs

Your repository URLs:
- Main: https://github.com/sinataee/ielts_reading_app
- Clone: https://github.com/sinataee/ielts_reading_app.git
- Issues: https://github.com/sinataee/ielts_reading_app/issues
- Releases: https://github.com/sinataee/ielts_reading_app/releases
- Wiki: https://github.com/sinataee/ielts_reading_app/wiki

## üÜò Need Help?

If you need help with any of these steps:
1. Check GitHub documentation: https://docs.github.com
2. Create an issue in your repository
3. Ask in this chat!

## üìß Sharing Your Repository

To share with others:
```
Check out my IELTS Reading Test Application!
üîó https://github.com/sinataee/ielts_reading_app

A comprehensive Python desktop app for IELTS test preparation with:
‚úÖ All 11 question types
‚úÖ Visual table & flowchart builders
‚úÖ Automatic band scoring
‚úÖ Fullscreen exam interface

Star ‚≠ê if you find it useful!
```

---

**Your repository is ready to share with the world! üéâ**

====================================================================================================
FILE: UPDATE_NOTES_v1.2.md
====================================================================================================

# IELTS Reading App - Version 1.2 Update Notes

## Major Improvements

### 1. Enhanced Type 9 (Summary/Table/Flow-chart) Input System

#### Previous Issue:
- Basic text area with no specialized controls
- No table builder functionality
- No flowchart creation tools
- Difficult to format content properly

#### New Features:

**A) Multi-Mode Input System**
Now when creating Type 9 questions, you can choose between three modes:
1. **Summary/Note** - Text-based summary with blanks
2. **Table** - Visual table builder with grid
3. **Flow-chart** - Flow-chart builder with special symbols

**B) Table Builder**
- **Dynamic Grid Creation**: Set number of rows (2-10) and columns (2-6)
- **Visual Table Editor**: Edit cells directly in a grid layout
- **Auto-formatting**: First row treated as headers
- **Blank Markers**: Use [BLANK], [1], [2], etc. in any cell
- **Scrollable**: Table area scrolls for large tables
- **Create Table Button**: Regenerates grid with new dimensions
- **Real-time Editing**: All cells are editable text fields

Example table creation:
```
Rows: 3
Columns: 4
[Create Table button]

+----------------+----------------+----------------+----------------+
| Header 1       | Header 2       | Header 3       | Header 4       |
+----------------+----------------+----------------+----------------+
| Data 1         | [BLANK]        | Data 3         | Data 4         |
+----------------+----------------+----------------+----------------+
| Data 5         | Data 6         | [1]            | Data 8         |
+----------------+----------------+----------------+----------------+
```

**C) Flow-chart Builder**
- **Large Text Area**: 10 rows for complex flow-charts
- **Quick Insert Buttons**:
  * ‚Üí (Right arrow)
  * ‚Üì (Down arrow)
  * ‚Üë (Up arrow)
  * ‚Üê (Left arrow)
  * Box (Pre-formatted box shape)
  * [BLANK] (Blank marker)
  * Decision (Diamond shape)
- **Template Provided**: Example flow-chart structures included
- **ASCII Art Support**: Use box-drawing characters
- **Flexible Format**: Describe flow-chart textually or draw it

Example flow-chart:
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Start     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   [1]       ‚îÇ  ‚Üê Blank to fill
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì
    ‚ï±‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï≤
   ‚ï± Decision ‚ï≤
  ‚ï±            ‚ï≤
  ‚ï≤    [2]     ‚ï±  ‚Üê Another blank
   ‚ï≤          ‚ï±
    ‚ï≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï±
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   End       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**D) Summary Mode**
- **Large Text Area**: 8 rows for detailed summaries
- **Blank Markers**: Use [1], [2], [3] or [BLANK]
- **Rich Text**: Can include multiple paragraphs
- **Helper Text**: Instructions provided in placeholder

### 2. Fullscreen Exam Interface

#### Previous Issue:
- Fixed window size (1400x900)
- Content didn't scale with screen
- Poor visibility on different monitors

#### New Features:

**A) Automatic Fullscreen**
- Exam window automatically opens fullscreen
- Uses `state('zoomed')` for Windows/Linux
- Fallback to `-zoomed` attribute for compatibility
- Minimum size enforced (1024x768)

**B) Responsive Layout**
- Screen dimensions detected automatically
- Content scales to fit screen size
- Split panes adjust proportionally
- Fonts sized appropriately

**C) Improved Typography**
- **Reading Passage**:
  * Explanation: 11pt italic, gray
  * Title: 18pt bold, centered
  * Paragraph titles: 14pt bold
  * Paragraph body: 12pt with line spacing
- **Questions**: Clear, readable fonts
- **Additional Info**: Highlighted for visibility

### 3. Enhanced Type 9 Display in Exams

#### Previous Issue:
- Small, plain text display
- Hard to find blanks quickly
- No visual distinction
- Difficult to read during timed exam

#### New Features:

**A) Visual Highlighting**
- **Yellow Highlighting**: All [BLANK], [1], [2], etc. highlighted in bright yellow
- **Bordered Frames**: Content in solid-bordered white boxes
- **Colored Headers**: Orange icons and headers (üìù, üìä, üîÑ)
- **Background Color**: Light yellow background (#fff9e6) for entire section

**B) Better Layout**
- **Summary**: 
  * Scrollable text box with cream background
  * Yellow highlighting on blanks
  * Large, readable font (11pt)
  * Padding for comfortable reading

- **Table**:
  * Visual grid with borders
  * Header row in gray (#f0f0f0)
  * Blank cells in yellow (#ffeb3b)
  * Proper spacing and alignment
  * Responsive column widths

- **Flow-chart**:
  * Monospace font (Courier 10pt) for alignment
  * Cream background (#fffef0)
  * Yellow highlighting on blanks
  * Preserves ASCII art formatting
  * Scrollable for large charts

**C) Clear Labeling**
- üìã "ADDITIONAL INFORMATION - READ CAREFULLY"
- üìù "SUMMARY - Complete the gaps below:"
- üìä "TABLE - Complete the gaps below:"
- üîÑ "FLOW-CHART - Complete the gaps below:"
- üìê "DIAGRAM:"

**D) Quick Scanning**
- Bold headers stand out
- Yellow blanks immediately visible
- Organized, clean presentation
- Easy to reference during exam

### 4. Improved Question Display

**A) Better Spacing**
- Increased padding in question frames
- Clear separation between questions
- More whitespace for readability

**B) Enhanced Readability**
- Larger fonts for question text (10pt)
- Better wrapping (wraplength: 600)
- Clear question numbering
- Type indicator in blue

**C) Multiple Choice Formatting**
- Each option on separate line
- Radio buttons aligned
- Full option text displayed
- Clear visual separation

### 5. Additional Improvements

**A) Import Statement Updates**
- Added `import re` for regex pattern matching
- Enables blank detection and highlighting
- Used for parsing [1], [2], [BLANK] patterns

**B) Code Organization**
- Better function separation
- Clear comments
- Logical flow
- Error handling

## Technical Details

### New Dependencies
- `re` module (Python standard library) - for pattern matching

### File Changes
1. **content_editor.py**:
   - Complete rewrite of Type 9 additional inputs section
   - Added table builder with Spinbox controls
   - Added flowchart builder with symbol buttons
   - Enhanced save logic to handle table data structure

2. **exam_engine.py**:
   - Added fullscreen initialization
   - Enhanced render_additional_inputs with visual styling
   - Improved font sizes and spacing
   - Added regex-based blank highlighting
   - Better table rendering with grid layout

### Data Structure
Table data now stored as:
```json
{
  "tableData": {
    "rows": 3,
    "cols": 4,
    "content": [
      ["Header 1", "Header 2", "Header 3", "Header 4"],
      ["Data 1", "[BLANK]", "Data 3", "Data 4"],
      ["Data 5", "Data 6", "[1]", "Data 8"]
    ]
  }
}
```

## User Impact

### For Content Creators
‚úÖ Much easier to create complex summaries
‚úÖ Visual table builder saves time
‚úÖ Flowchart symbols readily available
‚úÖ Can see exactly how it will look
‚úÖ Professional-looking output

### For Test Takers
‚úÖ Fullscreen provides better focus
‚úÖ Blanks immediately visible (yellow highlight)
‚úÖ Tables displayed clearly in grid format
‚úÖ Flowcharts preserve formatting
‚úÖ Less eye strain with larger fonts
‚úÖ Faster to find information during exam

### For Both
‚úÖ More professional appearance
‚úÖ Better user experience
‚úÖ Reduced errors
‚úÖ Clearer instructions
‚úÖ Improved accessibility

## Migration Notes

### Backward Compatibility
- ‚úÖ Old packages with simple summaryData still work
- ‚úÖ New table format is additive (doesn't break old data)
- ‚úÖ Flowchart data compatible with old summary field
- ‚ö†Ô∏è Re-save old Type 9 packages to get new features

### Recommended Actions
1. Test existing packages - they should still work
2. Re-create Type 9 questions using new builders for best results
3. Use fullscreen exam mode for optimal experience
4. Review QUESTION_TYPES_GUIDE.md for updated examples

## Known Limitations

1. **Table Builder**:
   - Maximum 10 rows, 6 columns
   - Basic formatting only
   - No cell merging
   - No colors/styling within cells

2. **Flowchart Builder**:
   - ASCII-based (not graphical)
   - Manual alignment required
   - Limited to monospace fonts
   - No auto-layout

3. **Fullscreen**:
   - May not work on all window managers
   - Falls back to normal window if unsupported
   - Minimum size requirements (1024x768)

## Future Enhancements (Possible)

- [ ] Graphical flowchart editor with drag-drop
- [ ] Rich table formatting (colors, borders, styles)
- [ ] Image insertion in summaries
- [ ] Export summaries/tables to different formats
- [ ] Multi-column table support
- [ ] Auto-detection of screen size for font scaling
- [ ] Dark mode for reduced eye strain
- [ ] Customizable color schemes

## Testing Checklist

- [x] Create Type 9 Summary question
- [x] Create Type 9 Table question (3x3, 5x4)
- [x] Create Type 9 Flowchart question
- [x] Display all three in exam mode
- [x] Verify fullscreen works
- [x] Check blank highlighting (yellow)
- [x] Test table grid display
- [x] Verify flowchart formatting preserved
- [x] Check backward compatibility with old packages
- [x] Test on different screen resolutions

## Version History

**v1.2** (Current)
- Enhanced Type 9 with table/flowchart builders
- Fullscreen exam interface
- Improved visual display of Type 9 content
- Better fonts and spacing

**v1.1**
- Fixed question type input requirements
- Added QUESTION_TYPES_GUIDE.md
- Improved multiple choice display
- Enhanced matching question dropdowns

**v1.0** (Initial Release)
- All 11 question types supported
- Content Editor, Exam Engine, Result Engine
- Basic Type 9 support
- Standard window size

---

**Last Updated**: February 10, 2025
**Version**: 1.2
**Status**: Production Ready ‚úÖ

====================================================================================================
FILE: requirements.txt
====================================================================================================

# IELTS Reading Test Application Requirements

# Python Standard Library modules (no installation needed)
# - tkinter (GUI framework)
# - json (data serialization)
# - datetime (time handling)
# - threading (timer functionality)
# - dataclasses (data models)
# - enum (enumerations)
# - uuid (unique identifiers)
# - typing (type hints)

# This application uses only Python standard library modules
# No additional pip packages required

# Minimum Python version: 3.7+
# Recommended Python version: 3.9+

# To verify your Python installation:
# python --version

# To verify tkinter is available:
# python -m tkinter

====================================================================================================
FILE: main.py
====================================================================================================

"""
IELTS Reading Application - Main Launcher
Provides a menu to launch different modules
"""
import tkinter as tk
from tkinter import messagebox
import sys
import os


class MainLauncher:
    """Main application launcher window"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("IELTS Reading Test Application")
        self.root.geometry("600x500")
        self.root.resizable(False, False)
        
        self.create_ui()
    
    def create_ui(self):
        """Create the launcher UI"""
        # Header
        header = tk.Frame(self.root, bg='#2c3e50', height=100)
        header.pack(fill=tk.X)
        header.pack_propagate(False)
        
        tk.Label(header, text="IELTS Reading Test", 
                font=('Arial', 24, 'bold'), bg='#2c3e50', fg='white').pack(pady=10)
        tk.Label(header, text="Comprehensive Test Preparation System", 
                font=('Arial', 12), bg='#2c3e50', fg='#ecf0f1').pack()
        
        # Main content
        content = tk.Frame(self.root, bg='#ecf0f1')
        content.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        tk.Label(content, text="Select a Module:", font=('Arial', 14, 'bold'),
                bg='#ecf0f1').pack(pady=20)
        
        # Module buttons
        buttons_frame = tk.Frame(content, bg='#ecf0f1')
        buttons_frame.pack(expand=True)
        
        # Content Editor button
        editor_btn = tk.Button(buttons_frame, text="Content Editor",
                              command=self.launch_content_editor,
                              bg='#3498db', fg='white', font=('Arial', 14, 'bold'),
                              width=25, height=2, cursor='hand2')
        editor_btn.pack(pady=10)
        
        tk.Label(buttons_frame, text="Create and edit reading packages",
                font=('Arial', 10, 'italic'), bg='#ecf0f1', fg='#7f8c8d').pack()
        
        # Exam Engine button
        exam_btn = tk.Button(buttons_frame, text="Take Exam",
                            command=self.launch_exam_engine,
                            bg='#27ae60', fg='white', font=('Arial', 14, 'bold'),
                            width=25, height=2, cursor='hand2')
        exam_btn.pack(pady=10)
        
        tk.Label(buttons_frame, text="Take a reading test with timing and scoring",
                font=('Arial', 10, 'italic'), bg='#ecf0f1', fg='#7f8c8d').pack()
        
        # Sample Package button
        sample_btn = tk.Button(buttons_frame, text="Create Sample Package",
                              command=self.create_sample_package,
                              bg='#f39c12', fg='white', font=('Arial', 14, 'bold'),
                              width=25, height=2, cursor='hand2')
        sample_btn.pack(pady=10)
        
        tk.Label(buttons_frame, text="Generate a sample reading package for testing",
                font=('Arial', 10, 'italic'), bg='#ecf0f1', fg='#7f8c8d').pack()
        
        # Footer
        footer = tk.Frame(self.root, bg='#34495e', height=60)
        footer.pack(fill=tk.X, side=tk.BOTTOM)
        footer.pack_propagate(False)
        
        tk.Label(footer, text="¬© 2025 IELTS Reading Test Application", 
                font=('Arial', 10), bg='#34495e', fg='white').pack(pady=5)
        
        tk.Button(footer, text="Exit", command=self.root.quit,
                 bg='#e74c3c', fg='white', font=('Arial', 10, 'bold'),
                 width=10).pack(pady=5)
    
    def launch_content_editor(self):
        """Launch the Content Editor module"""
        try:
            import content_editor
            editor_window = tk.Toplevel(self.root)
            content_editor.ContentEditorWindow(editor_window)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to launch Content Editor:\n{str(e)}")
    
    def launch_exam_engine(self):
        """Launch the Exam Engine module"""
        try:
            import exam_engine
            exam_window = tk.Toplevel(self.root)
            exam_engine.ExamEngineWindow(exam_window)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to launch Exam Engine:\n{str(e)}")
    
    def create_sample_package(self):
        """Create a sample reading package"""
        from tkinter import filedialog
        from models import (
            ReadingPackage, ReadingContent, Paragraph, 
            QuestionGroup, Question, QuestionType
        )
        import uuid
        
        # Create sample package
        package = ReadingPackage()
        package.package_id = str(uuid.uuid4())
        
        # Reading content
        rc = ReadingContent()
        rc.explanation = "You should spend about 20 minutes on Questions 1-13, which are based on the reading passage below."
        rc.title = "The History of the Bicycle"
        
        # Add paragraphs
        para1 = Paragraph()
        para1.title = "Early Developments"
        para1.body = """The bicycle has a long and fascinating history. The first verifiable claim for a 
practically used bicycle belongs to German inventor Karl von Drais. In 1817, he created a two-wheeled 
vehicle which was propelled by pushing one's feet against the ground. This early bicycle, known as the 
'running machine' or 'hobby horse', was made entirely of wood and had no pedals."""
        
        para2 = Paragraph()
        para2.title = "The Penny-Farthing Era"
        para2.body = """By the 1870s, bicycles had evolved significantly. The penny-farthing, with its 
large front wheel and small rear wheel, became popular among young men. The large wheel allowed for 
greater speed, but made the bicycle difficult and dangerous to ride. Mounting and dismounting required 
considerable skill, and falls were common."""
        
        para3 = Paragraph()
        para3.title = "The Safety Bicycle"
        para3.body = """The 1890s saw the introduction of the 'safety bicycle', which had two equal-sized 
wheels and a chain drive. This design, which is still used in modern bicycles, was much safer and easier 
to ride than the penny-farthing. The invention of pneumatic tires by John Boyd Dunlop in 1888 further 
improved comfort and performance."""
        
        rc.paragraphs = [para1, para2, para3]
        package.reading_content = rc
        
        # Question Group 1: Multiple Choice
        qg1 = QuestionGroup()
        qg1.type = QuestionType.TYPE1
        qg1.explanation = "Choose the correct letter, A, B, C or D."
        
        q1 = Question()
        q1.question_id = f"{package.package_id}_qg1_q1"
        q1.text = """Who invented the first practical bicycle?
A. Karl von Drais
B. John Boyd Dunlop
C. Pierre Lallement
D. Ernest Michaux"""
        q1.answer = "A"
        
        q2 = Question()
        q2.question_id = f"{package.package_id}_qg1_q2"
        q2.text = """What was the penny-farthing's main disadvantage?
A. It was too expensive
B. It was dangerous to ride
C. It was too heavy
D. It was too slow"""
        q2.answer = "B"
        
        qg1.questions = [q1, q2]
        
        # Question Group 2: True/False/Not Given
        qg2 = QuestionGroup()
        qg2.type = QuestionType.TYPE2
        qg2.explanation = "Do the following statements agree with the information in the passage? Write TRUE, FALSE, or NOT GIVEN."
        
        q3 = Question()
        q3.question_id = f"{package.package_id}_qg2_q1"
        q3.text = "The running machine had pedals"
        q3.answer = "FALSE"
        
        q4 = Question()
        q4.question_id = f"{package.package_id}_qg2_q2"
        q4.text = "The penny-farthing was popular among young men"
        q4.answer = "TRUE"
        
        q5 = Question()
        q5.question_id = f"{package.package_id}_qg2_q3"
        q5.text = "The safety bicycle was invented in France"
        q5.answer = "NOT GIVEN"
        
        qg2.questions = [q3, q4, q5]
        
        # Question Group 3: Short Answer
        qg3 = QuestionGroup()
        qg3.type = QuestionType.TYPE11
        qg3.explanation = "Answer the questions below using NO MORE THAN THREE WORDS from the passage."
        
        q6 = Question()
        q6.question_id = f"{package.package_id}_qg3_q1"
        q6.text = "What material was the running machine made from?"
        q6.answer = "wood"
        
        q7 = Question()
        q7.question_id = f"{package.package_id}_qg3_q2"
        q7.text = "Who invented pneumatic tires?"
        q7.answer = "John Boyd Dunlop"
        
        q8 = Question()
        q8.question_id = f"{package.package_id}_qg3_q3"
        q8.text = "In which decade was the safety bicycle introduced?"
        q8.answer = "1890s"
        
        qg3.questions = [q6, q7, q8]
        
        # Question Group 4: Matching Information (example)
        qg4 = QuestionGroup()
        qg4.type = QuestionType.TYPE4
        qg4.explanation = "Match each statement with the correct paragraph (A, B, or C)."
        
        # Create additional inputs for matching
        from models import AdditionalInput
        qg4.additional_inputs = AdditionalInput(
            input_type=QuestionType.TYPE4.value,
            data={
                'infoList': [
                    'A. Early Developments',
                    'B. The Penny-Farthing Era', 
                    'C. The Safety Bicycle'
                ]
            }
        )
        
        q9 = Question()
        q9.question_id = f"{package.package_id}_qg4_q1"
        q9.text = "Which paragraph mentions the invention of pneumatic tires?"
        q9.answer = "C"
        
        q10 = Question()
        q10.question_id = f"{package.package_id}_qg4_q2"
        q10.text = "Which paragraph describes a bicycle made entirely of wood?"
        q10.answer = "A"
        
        qg4.questions = [q9, q10]
        
        package.question_groups = [qg1, qg2, qg3, qg4]
        
        # Save package
        filepath = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
            initialfile="sample_bicycle_history.json"
        )
        
        if filepath:
            try:
                package.save_to_file(filepath)
                messagebox.showinfo("Success", 
                                  f"Sample package created successfully!\n\n"
                                  f"Package: The History of the Bicycle\n"
                                  f"Questions: 8\n"
                                  f"File: {filepath}\n\n"
                                  f"You can now open this package in the Exam Engine to take the test.")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to create sample package:\n{str(e)}")


def main():
    """Main entry point"""
    root = tk.Tk()
    app = MainLauncher(root)
    root.mainloop()


if __name__ == "__main__":
    main()

====================================================================================================
FILE: models.py
====================================================================================================

"""
Data Models for IELTS Reading Application
Based on Class Diagram specifications
"""
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum
import json


class QuestionType(Enum):
    """Enum for different question types in IELTS Reading"""
    TYPE1 = "Multiple Choice"
    TYPE2 = "True/False/Not Given"
    TYPE3 = "Yes/No/Not Given"
    TYPE4 = "Matching Information"
    TYPE5 = "Matching Headings"
    TYPE6 = "Matching Features"
    TYPE7 = "Matching Sentence Endings"
    TYPE8 = "Sentence Completion"
    TYPE9 = "Summary/Table/Flow-chart Completion"
    TYPE10 = "Diagram Label Completion"
    TYPE11 = "Short Answer Questions"


@dataclass
class Paragraph:
    """Represents a paragraph in reading content"""
    title: str = ""
    body: str = ""
    
    def to_dict(self) -> Dict:
        return {
            'title': self.title,
            'body': self.body
        }
    
    @staticmethod
    def from_dict(data: Dict) -> 'Paragraph':
        return Paragraph(
            title=data.get('title', ''),
            body=data.get('body', '')
        )


@dataclass
class ReadingContent:
    """Represents the reading passage content"""
    explanation: str = ""
    title: str = ""
    paragraphs: List[Paragraph] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            'explanation': self.explanation,
            'title': self.title,
            'paragraphs': [p.to_dict() for p in self.paragraphs]
        }
    
    @staticmethod
    def from_dict(data: Dict) -> 'ReadingContent':
        return ReadingContent(
            explanation=data.get('explanation', ''),
            title=data.get('title', ''),
            paragraphs=[Paragraph.from_dict(p) for p in data.get('paragraphs', [])]
        )


@dataclass
class Question:
    """Represents a single question"""
    text: str = ""
    answer: str = ""
    question_id: str = ""
    
    def to_dict(self) -> Dict:
        return {
            'text': self.text,
            'answer': self.answer,
            'question_id': self.question_id
        }
    
    @staticmethod
    def from_dict(data: Dict) -> 'Question':
        return Question(
            text=data.get('text', ''),
            answer=data.get('answer', ''),
            question_id=data.get('question_id', '')
        )


@dataclass
class AdditionalInput:
    """Base class for additional inputs based on question type"""
    input_type: str = ""
    data: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict:
        return {
            'input_type': self.input_type,
            'data': self.data
        }
    
    @staticmethod
    def from_dict(data: Dict) -> 'AdditionalInput':
        return AdditionalInput(
            input_type=data.get('input_type', ''),
            data=data.get('data', {})
        )


@dataclass
class QuestionGroup:
    """Represents a group of questions of the same type"""
    explanation: str = ""
    type: QuestionType = QuestionType.TYPE1
    questions: List[Question] = field(default_factory=list)
    additional_inputs: Optional[AdditionalInput] = None
    
    def validate(self) -> bool:
        """Validate question count (min 2, max 10)"""
        return 2 <= len(self.questions) <= 10
    
    def to_dict(self) -> Dict:
        return {
            'explanation': self.explanation,
            'type': self.type.value,
            'questions': [q.to_dict() for q in self.questions],
            'additional_inputs': self.additional_inputs.to_dict() if self.additional_inputs else None
        }
    
    @staticmethod
    def from_dict(data: Dict) -> 'QuestionGroup':
        # Find matching QuestionType
        question_type = QuestionType.TYPE1
        for qt in QuestionType:
            if qt.value == data.get('type'):
                question_type = qt
                break
        
        return QuestionGroup(
            explanation=data.get('explanation', ''),
            type=question_type,
            questions=[Question.from_dict(q) for q in data.get('questions', [])],
            additional_inputs=AdditionalInput.from_dict(data['additional_inputs']) 
                if data.get('additional_inputs') else None
        )


@dataclass
class ReadingPackage:
    """Complete reading package with content and questions"""
    package_id: str = ""
    reading_content: ReadingContent = field(default_factory=ReadingContent)
    question_groups: List[QuestionGroup] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict:
        return {
            'package_id': self.package_id,
            'reading_content': self.reading_content.to_dict(),
            'question_groups': [qg.to_dict() for qg in self.question_groups],
            'created_at': self.created_at.isoformat()
        }
    
    @staticmethod
    def from_dict(data: Dict) -> 'ReadingPackage':
        return ReadingPackage(
            package_id=data.get('package_id', ''),
            reading_content=ReadingContent.from_dict(data.get('reading_content', {})),
            question_groups=[QuestionGroup.from_dict(qg) for qg in data.get('question_groups', [])],
            created_at=datetime.fromisoformat(data.get('created_at', datetime.now().isoformat()))
        )
    
    def save_to_file(self, filepath: str):
        """Save package to JSON file"""
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(self.to_dict(), f, indent=2, ensure_ascii=False)
    
    @staticmethod
    def load_from_file(filepath: str) -> 'ReadingPackage':
        """Load package from JSON file"""
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
        return ReadingPackage.from_dict(data)


@dataclass
class AnswerRecord:
    """Records user's answer to a question"""
    question_id: str
    user_answer: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict:
        return {
            'question_id': self.question_id,
            'user_answer': self.user_answer,
            'timestamp': self.timestamp.isoformat()
        }


@dataclass
class HighlightRecord:
    """Records text highlighting during exam"""
    selection_range: str
    highlight_color: str
    timestamp: datetime = field(default_factory=datetime.now)


@dataclass
class FeedbackItem:
    """Feedback for a single question"""
    question_id: str
    is_correct: bool
    correct_answer: str
    user_answer: Optional[str]
    
    def to_dict(self) -> Dict:
        return {
            'question_id': self.question_id,
            'is_correct': self.is_correct,
            'correct_answer': self.correct_answer,
            'user_answer': self.user_answer
        }


@dataclass
class EvaluationResult:
    """Complete evaluation result"""
    correct_count: int = 0
    incorrect_count: int = 0
    unanswered_count: int = 0
    total_questions: int = 0
    band_score: float = 0.0
    per_question_feedback: List[FeedbackItem] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            'correct_count': self.correct_count,
            'incorrect_count': self.incorrect_count,
            'unanswered_count': self.unanswered_count,
            'total_questions': self.total_questions,
            'band_score': self.band_score,
            'per_question_feedback': [f.to_dict() for f in self.per_question_feedback]
        }


@dataclass
class IELTSScoringRules:
    """IELTS band score mapping"""
    mapping: Dict[int, float] = field(default_factory=dict)
    
    @staticmethod
    def get_academic_rules() -> 'IELTSScoringRules':
        """Standard IELTS Academic Reading band scores"""
        mapping = {
            0: 0.0, 1: 1.0, 2: 2.0, 3: 2.5, 4: 3.0, 5: 3.5,
            6: 4.0, 7: 4.0, 8: 4.5, 9: 4.5, 10: 5.0,
            11: 5.0, 12: 5.5, 13: 5.5, 14: 6.0, 15: 6.0,
            16: 6.5, 17: 6.5, 18: 6.5, 19: 7.0, 20: 7.0,
            21: 7.0, 22: 7.0, 23: 7.5, 24: 7.5, 25: 8.0,
            26: 8.0, 27: 8.0, 28: 8.0, 29: 8.5, 30: 8.5,
            31: 8.5, 32: 8.5, 33: 9.0, 34: 9.0, 35: 9.0,
            36: 9.0, 37: 9.0, 38: 9.0, 39: 9.0, 40: 9.0
        }
        return IELTSScoringRules(mapping=mapping)

====================================================================================================
FILE: content_editor.py
====================================================================================================

"""
Content Editor Module
Provides tools for creating, editing, and storing complete IELTS reading packages
"""
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog, font as tkfont
from typing import Optional
import uuid
from models import (
    ReadingPackage, ReadingContent, Paragraph, QuestionGroup,
    Question, QuestionType, AdditionalInput
)


class RichTextEditor(tk.Frame):
    """Rich text editor with formatting toolbar"""
    
    def __init__(self, parent, height=10):
        super().__init__(parent)
        
        # Toolbar
        toolbar = tk.Frame(self)
        toolbar.pack(fill=tk.X, padx=5, pady=5)
        
        # Bold button
        self.bold_btn = tk.Button(toolbar, text="B", font=('Arial', 10, 'bold'),
                                   width=3, command=self.toggle_bold)
        self.bold_btn.pack(side=tk.LEFT, padx=2)
        
        # Italic button
        self.italic_btn = tk.Button(toolbar, text="I", font=('Arial', 10, 'italic'),
                                     width=3, command=self.toggle_italic)
        self.italic_btn.pack(side=tk.LEFT, padx=2)
        
        # Font size
        tk.Label(toolbar, text="Size:").pack(side=tk.LEFT, padx=2)
        self.size_var = tk.StringVar(value="12")
        size_combo = ttk.Combobox(toolbar, textvariable=self.size_var, 
                                   values=['10', '12', '14', '16', '18', '20'], width=5)
        size_combo.pack(side=tk.LEFT, padx=2)
        size_combo.bind('<<ComboboxSelected>>', self.change_size)
        
        # Header styles
        tk.Button(toolbar, text="H1", command=lambda: self.apply_header(1)).pack(side=tk.LEFT, padx=2)
        tk.Button(toolbar, text="H2", command=lambda: self.apply_header(2)).pack(side=tk.LEFT, padx=2)
        
        # Alignment
        tk.Button(toolbar, text="Left", command=lambda: self.set_align('left')).pack(side=tk.LEFT, padx=2)
        tk.Button(toolbar, text="Center", command=lambda: self.set_align('center')).pack(side=tk.LEFT, padx=2)
        
        # Text widget
        self.text = scrolledtext.ScrolledText(self, height=height, wrap=tk.WORD, font=('Arial', 12))
        self.text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Configure tags
        self.text.tag_configure('bold', font=('Arial', 12, 'bold'))
        self.text.tag_configure('italic', font=('Arial', 12, 'italic'))
        self.text.tag_configure('h1', font=('Arial', 18, 'bold'))
        self.text.tag_configure('h2', font=('Arial', 16, 'bold'))
        self.text.tag_configure('center', justify='center')
        self.text.tag_configure('left', justify='left')
    
    def toggle_bold(self):
        try:
            current_tags = self.text.tag_names("sel.first")
            if "bold" in current_tags:
                self.text.tag_remove("bold", "sel.first", "sel.last")
            else:
                self.text.tag_add("bold", "sel.first", "sel.last")
        except tk.TclError:
            pass
    
    def toggle_italic(self):
        try:
            current_tags = self.text.tag_names("sel.first")
            if "italic" in current_tags:
                self.text.tag_remove("italic", "sel.first", "sel.last")
            else:
                self.text.tag_add("italic", "sel.first", "sel.last")
        except tk.TclError:
            pass
    
    def change_size(self, event=None):
        size = int(self.size_var.get())
        self.text.configure(font=('Arial', size))
    
    def apply_header(self, level):
        try:
            tag = f'h{level}'
            self.text.tag_add(tag, "sel.first", "sel.last")
        except tk.TclError:
            pass
    
    def set_align(self, alignment):
        try:
            self.text.tag_add(alignment, "sel.first", "sel.last")
        except tk.TclError:
            # Apply to entire text if no selection
            self.text.tag_add(alignment, "1.0", "end")
    
    def get_text(self) -> str:
        return self.text.get("1.0", "end-1c")
    
    def set_text(self, text: str):
        self.text.delete("1.0", "end")
        self.text.insert("1.0", text)
    
    def clear(self):
        self.text.delete("1.0", "end")


class ContentEditorWindow:
    """Main Content Editor Window"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("IELTS Content Editor")
        self.root.geometry("1200x800")
        
        self.current_package = ReadingPackage()
        self.current_package.package_id = str(uuid.uuid4())
        
        self.create_ui()
    
    def create_ui(self):
        # Menu bar
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="New Package", command=self.new_package)
        file_menu.add_command(label="Open Package", command=self.open_package)
        file_menu.add_command(label="Save Package", command=self.save_package)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.root.quit)
        
        # Main container
        main_frame = tk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Notebook for tabs
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Tab 1: Reading Content
        self.create_reading_content_tab()
        
        # Tab 2: Question Groups
        self.create_question_groups_tab()
        
        # Status bar
        self.status_bar = tk.Label(self.root, text="Ready", bd=1, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
    
    def create_reading_content_tab(self):
        tab = tk.Frame(self.notebook)
        self.notebook.add(tab, text="Reading Content")
        
        # Canvas with scrollbar
        canvas = tk.Canvas(tab)
        scrollbar = ttk.Scrollbar(tab, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Explanation
        tk.Label(scrollable_frame, text="Explanation:", font=('Arial', 12, 'bold')).pack(anchor=tk.W, padx=10, pady=5)
        self.explanation_editor = RichTextEditor(scrollable_frame, height=5)
        self.explanation_editor.pack(fill=tk.X, padx=10, pady=5)
        
        # Title
        tk.Label(scrollable_frame, text="Title:", font=('Arial', 12, 'bold')).pack(anchor=tk.W, padx=10, pady=5)
        self.title_editor = RichTextEditor(scrollable_frame, height=3)
        self.title_editor.pack(fill=tk.X, padx=10, pady=5)
        
        # Paragraphs
        tk.Label(scrollable_frame, text="Paragraphs:", font=('Arial', 12, 'bold')).pack(anchor=tk.W, padx=10, pady=5)
        
        self.paragraph_frame = tk.Frame(scrollable_frame)
        self.paragraph_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        self.paragraph_editors = []
        
        # Add paragraph button
        tk.Button(scrollable_frame, text="Add Paragraph", command=self.add_paragraph).pack(pady=10)
        
        # Save reading content button
        tk.Button(scrollable_frame, text="Save Reading Content", 
                 command=self.save_reading_content, bg='green', fg='white').pack(pady=10)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
    
    def add_paragraph(self):
        """Add a new paragraph editor"""
        para_container = tk.LabelFrame(self.paragraph_frame, text=f"Paragraph {len(self.paragraph_editors) + 1}")
        para_container.pack(fill=tk.BOTH, expand=True, pady=5)
        
        tk.Label(para_container, text="Paragraph Title:").pack(anchor=tk.W, padx=5)
        title_editor = RichTextEditor(para_container, height=2)
        title_editor.pack(fill=tk.X, padx=5, pady=2)
        
        tk.Label(para_container, text="Paragraph Body:").pack(anchor=tk.W, padx=5)
        body_editor = RichTextEditor(para_container, height=8)
        body_editor.pack(fill=tk.X, padx=5, pady=2)
        
        # Remove button
        tk.Button(para_container, text="Remove Paragraph", 
                 command=lambda: self.remove_paragraph(para_container)).pack(pady=5)
        
        self.paragraph_editors.append({
            'container': para_container,
            'title': title_editor,
            'body': body_editor
        })
    
    def remove_paragraph(self, container):
        """Remove a paragraph editor"""
        self.paragraph_editors = [p for p in self.paragraph_editors if p['container'] != container]
        container.destroy()
    
    def save_reading_content(self):
        """Save reading content to current package"""
        reading_content = ReadingContent()
        reading_content.explanation = self.explanation_editor.get_text()
        reading_content.title = self.title_editor.get_text()
        
        for para_editor in self.paragraph_editors:
            paragraph = Paragraph()
            paragraph.title = para_editor['title'].get_text()
            paragraph.body = para_editor['body'].get_text()
            reading_content.paragraphs.append(paragraph)
        
        self.current_package.reading_content = reading_content
        self.status_bar.config(text="Reading content saved")
        messagebox.showinfo("Success", "Reading content saved successfully!")
    
    def create_question_groups_tab(self):
        tab = tk.Frame(self.notebook)
        self.notebook.add(tab, text="Question Groups")
        
        # Toolbar
        toolbar = tk.Frame(tab)
        toolbar.pack(fill=tk.X, padx=10, pady=5)
        
        tk.Button(toolbar, text="Add Question Group", command=self.add_question_group).pack(side=tk.LEFT, padx=5)
        tk.Button(toolbar, text="View Groups", command=self.view_question_groups).pack(side=tk.LEFT, padx=5)
        
        # Question group frame
        self.qg_frame = tk.Frame(tab)
        self.qg_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    def add_question_group(self):
        """Open dialog to add question group"""
        dialog = tk.Toplevel(self.root)
        dialog.title("Add Question Group")
        dialog.geometry("1000x750")
        
        # Make dialog scrollable
        main_canvas = tk.Canvas(dialog)
        scrollbar = ttk.Scrollbar(dialog, orient="vertical", command=main_canvas.yview)
        scrollable_dialog = tk.Frame(main_canvas)
        
        scrollable_dialog.bind(
            "<Configure>",
            lambda e: main_canvas.configure(scrollregion=main_canvas.bbox("all"))
        )
        
        main_canvas.create_window((0, 0), window=scrollable_dialog, anchor="nw")
        main_canvas.configure(yscrollcommand=scrollbar.set)
        
        # Explanation
        tk.Label(scrollable_dialog, text="Explanation:", font=('Arial', 10, 'bold')).pack(anchor=tk.W, padx=10, pady=5)
        explanation_editor = RichTextEditor(scrollable_dialog, height=3)
        explanation_editor.pack(fill=tk.X, padx=10, pady=5)
        
        # Question Type
        tk.Label(scrollable_dialog, text="Question Type:", font=('Arial', 10, 'bold')).pack(anchor=tk.W, padx=10, pady=5)
        type_var = tk.StringVar(value=QuestionType.TYPE1.value)
        type_combo = ttk.Combobox(scrollable_dialog, textvariable=type_var, 
                                  values=[qt.value for qt in QuestionType], width=50, state='readonly')
        type_combo.pack(anchor=tk.W, padx=10)
        
        # Additional inputs frame (for lists, images, etc.)
        additional_frame = tk.LabelFrame(scrollable_dialog, text="Additional Inputs (depends on question type)", 
                                        font=('Arial', 10, 'bold'), padx=10, pady=10)
        additional_frame.pack(fill=tk.X, padx=10, pady=10)
        
        additional_widgets = {}
        
        def update_additional_inputs(*args):
            """Update additional input fields based on question type"""
            # Clear existing widgets
            for widget in additional_frame.winfo_children():
                widget.destroy()
            additional_widgets.clear()
            
            selected_type = type_var.get()
            
            if selected_type == QuestionType.TYPE4.value:  # Matching information
                tk.Label(additional_frame, text="List of Information (one per line):", 
                        font=('Arial', 9)).pack(anchor=tk.W, pady=5)
                info_text = scrolledtext.ScrolledText(additional_frame, height=6, width=70)
                info_text.pack(fill=tk.X, pady=5)
                info_text.insert("1.0", "A. First piece of information\nB. Second piece of information\nC. Third piece of information")
                additional_widgets['infoList'] = info_text
                
            elif selected_type == QuestionType.TYPE5.value:  # Matching headings
                tk.Label(additional_frame, text="List of Headings (one per line):", 
                        font=('Arial', 9)).pack(anchor=tk.W, pady=5)
                heading_text = scrolledtext.ScrolledText(additional_frame, height=6, width=70)
                heading_text.pack(fill=tk.X, pady=5)
                heading_text.insert("1.0", "i. First heading\nii. Second heading\niii. Third heading")
                additional_widgets['headingList'] = heading_text
                
            elif selected_type == QuestionType.TYPE6.value:  # Matching features
                tk.Label(additional_frame, text="List of Features (one per line):", 
                        font=('Arial', 9)).pack(anchor=tk.W, pady=5)
                feature_text = scrolledtext.ScrolledText(additional_frame, height=6, width=70)
                feature_text.pack(fill=tk.X, pady=5)
                feature_text.insert("1.0", "A. Feature one\nB. Feature two\nC. Feature three")
                additional_widgets['featureList'] = feature_text
                
            elif selected_type == QuestionType.TYPE7.value:  # Matching sentence endings
                tk.Label(additional_frame, text="List of Sentence Endings (one per line):", 
                        font=('Arial', 9)).pack(anchor=tk.W, pady=5)
                ending_text = scrolledtext.ScrolledText(additional_frame, height=6, width=70)
                ending_text.pack(fill=tk.X, pady=5)
                ending_text.insert("1.0", "A. ending one.\nB. ending two.\nC. ending three.")
                additional_widgets['sentenceEndingList'] = ending_text
                
            elif selected_type == QuestionType.TYPE9.value:  # Summary/table/flow-chart
                tk.Label(additional_frame, text="Choose Input Type:", 
                        font=('Arial', 9, 'bold')).pack(anchor=tk.W, pady=5)
                
                input_type_var = tk.StringVar(value="Summary")
                input_type_frame = tk.Frame(additional_frame)
                input_type_frame.pack(anchor=tk.W, pady=5)
                
                tk.Radiobutton(input_type_frame, text="Summary/Note", variable=input_type_var, 
                              value="Summary").pack(side=tk.LEFT, padx=5)
                tk.Radiobutton(input_type_frame, text="Table", variable=input_type_var, 
                              value="Table").pack(side=tk.LEFT, padx=5)
                tk.Radiobutton(input_type_frame, text="Flow-chart", variable=input_type_var, 
                              value="Flowchart").pack(side=tk.LEFT, padx=5)
                
                # Content frame that changes based on selection
                content_frame = tk.Frame(additional_frame)
                content_frame.pack(fill=tk.BOTH, expand=True, pady=5)
                
                def update_type9_input():
                    for widget in content_frame.winfo_children():
                        widget.destroy()
                    
                    input_type = input_type_var.get()
                    
                    if input_type == "Summary":
                        tk.Label(content_frame, text="Summary Text (use [1], [2], [3] for blanks):", 
                                font=('Arial', 9)).pack(anchor=tk.W)
                        summary_text = scrolledtext.ScrolledText(content_frame, height=8, width=70)
                        summary_text.pack(fill=tk.BOTH, pady=5)
                        summary_text.insert("1.0", "Enter your summary here. Use [1] for first blank, [2] for second blank, etc.\nExample: The bicycle was invented in [1] by [2].")
                        additional_widgets['summaryData'] = summary_text
                        additional_widgets['type9_mode'] = 'summary'
                    
                    elif input_type == "Table":
                        table_builder_frame = tk.LabelFrame(content_frame, text="Table Builder", 
                                                           font=('Arial', 9, 'bold'), padx=5, pady=5)
                        table_builder_frame.pack(fill=tk.BOTH, expand=True)
                        
                        # Table controls
                        control_frame = tk.Frame(table_builder_frame)
                        control_frame.pack(fill=tk.X, pady=5)
                        
                        tk.Label(control_frame, text="Rows:").pack(side=tk.LEFT, padx=5)
                        rows_var = tk.StringVar(value="3")
                        tk.Spinbox(control_frame, from_=2, to=10, textvariable=rows_var, width=5).pack(side=tk.LEFT)
                        
                        tk.Label(control_frame, text="Columns:").pack(side=tk.LEFT, padx=5)
                        cols_var = tk.StringVar(value="3")
                        tk.Spinbox(control_frame, from_=2, to=6, textvariable=cols_var, width=5).pack(side=tk.LEFT)
                        
                        table_data = {'rows': rows_var, 'cols': cols_var, 'cells': {}}
                        
                        def create_table():
                            # Clear existing table
                            for widget in table_display_frame.winfo_children():
                                widget.destroy()
                            
                            rows = int(rows_var.get())
                            cols = int(cols_var.get())
                            table_data['cells'] = {}
                            
                            # Create table grid
                            for r in range(rows):
                                for c in range(cols):
                                    cell_entry = tk.Entry(table_display_frame, width=15)
                                    cell_entry.grid(row=r, column=c, padx=2, pady=2, sticky='ew')
                                    
                                    # Pre-fill header row
                                    if r == 0:
                                        cell_entry.insert(0, f"Header {c+1}")
                                    
                                    table_data['cells'][f"{r},{c}"] = cell_entry
                            
                            # Configure column weights for expansion
                            for c in range(cols):
                                table_display_frame.columnconfigure(c, weight=1)
                        
                        tk.Button(control_frame, text="Create Table", command=create_table,
                                 bg='#3498db', fg='white').pack(side=tk.LEFT, padx=10)
                        
                        tk.Label(control_frame, text="Use [BLANK] or [1], [2], etc. for gaps",
                                font=('Arial', 8, 'italic')).pack(side=tk.LEFT, padx=10)
                        
                        # Table display area with scrollbar
                        table_scroll_frame = tk.Frame(table_builder_frame)
                        table_scroll_frame.pack(fill=tk.BOTH, expand=True, pady=5)
                        
                        table_canvas = tk.Canvas(table_scroll_frame, height=200)
                        table_scrollbar = tk.Scrollbar(table_scroll_frame, orient="vertical", 
                                                      command=table_canvas.yview)
                        table_display_frame = tk.Frame(table_canvas)
                        
                        table_display_frame.bind("<Configure>", 
                                                lambda e: table_canvas.configure(scrollregion=table_canvas.bbox("all")))
                        
                        table_canvas.create_window((0, 0), window=table_display_frame, anchor="nw")
                        table_canvas.configure(yscrollcommand=table_scrollbar.set)
                        
                        table_canvas.pack(side="left", fill="both", expand=True)
                        table_scrollbar.pack(side="right", fill="y")
                        
                        # Create initial table
                        create_table()
                        
                        additional_widgets['tableData'] = table_data
                        additional_widgets['type9_mode'] = 'table'
                    
                    else:  # Flowchart
                        flowchart_frame = tk.LabelFrame(content_frame, text="Flow-chart Builder",
                                                       font=('Arial', 9, 'bold'), padx=5, pady=5)
                        flowchart_frame.pack(fill=tk.BOTH, expand=True)
                        
                        tk.Label(flowchart_frame, text="Flow-chart Structure (use ‚Üí for arrows, [BLANK] for gaps):",
                                font=('Arial', 9)).pack(anchor=tk.W, pady=5)
                        
                        # Flowchart text editor
                        flowchart_text = scrolledtext.ScrolledText(flowchart_frame, height=10, width=70)
                        flowchart_text.pack(fill=tk.BOTH, expand=True, pady=5)
                        
                        flowchart_template = """Enter your flow-chart structure here. Examples:

Simple flow:
[Start] ‚Üí [Process 1] ‚Üí [BLANK] ‚Üí [End]

Vertical flow:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Start     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   [1]       ‚îÇ  ‚Üê Use [1], [2] for blanks
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   End       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Or describe it:
Step 1: Starting point
   ‚Üì
Step 2: [BLANK] (to be filled)
   ‚Üì
Step 3: Final outcome
"""
                        flowchart_text.insert("1.0", flowchart_template)
                        
                        # Flowchart tools
                        tools_frame = tk.Frame(flowchart_frame)
                        tools_frame.pack(fill=tk.X, pady=5)
                        
                        tk.Label(tools_frame, text="Quick Insert:", font=('Arial', 9, 'bold')).pack(side=tk.LEFT, padx=5)
                        
                        def insert_symbol(symbol):
                            flowchart_text.insert(tk.INSERT, symbol)
                        
                        symbols = [
                            ("‚Üí", "‚Üí"), ("‚Üì", "‚Üì"), ("‚Üë", "‚Üë"), ("‚Üê", "‚Üê"),
                            ("Box", "\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ             ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n"),
                            ("[BLANK]", "[BLANK]"),
                            ("Decision", "\n    ‚ï±‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï≤\n   ‚ï±          ‚ï≤\n  ‚ï±            ‚ï≤\n  ‚ï≤            ‚ï±\n   ‚ï≤          ‚ï±\n    ‚ï≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï±\n")
                        ]
                        
                        for label, symbol in symbols:
                            tk.Button(tools_frame, text=label, 
                                     command=lambda s=symbol: insert_symbol(s),
                                     width=8).pack(side=tk.LEFT, padx=2)
                        
                        additional_widgets['flowchartData'] = flowchart_text
                        additional_widgets['type9_mode'] = 'flowchart'
                
                # Bind radio buttons
                for widget in input_type_frame.winfo_children():
                    if isinstance(widget, tk.Radiobutton):
                        widget.configure(command=update_type9_input)
                
                additional_widgets['type9_selector'] = input_type_var
                update_type9_input()  # Initialize
                
            elif selected_type == QuestionType.TYPE10.value:  # Diagram label completion
                tk.Label(additional_frame, text="Diagram Description/Image Path:", 
                        font=('Arial', 9)).pack(anchor=tk.W, pady=5)
                diagram_text = scrolledtext.ScrolledText(additional_frame, height=4, width=70)
                diagram_text.pack(fill=tk.X, pady=5)
                diagram_text.insert("1.0", "Enter diagram description or image file path")
                additional_widgets['diagramImage'] = diagram_text
            else:
                tk.Label(additional_frame, text="No additional inputs required for this question type.", 
                        font=('Arial', 9, 'italic'), fg='gray').pack(pady=10)
        
        # Bind the update function to type change
        type_combo.bind('<<ComboboxSelected>>', update_additional_inputs)
        update_additional_inputs()  # Initialize
        
        # Questions section
        tk.Label(scrollable_dialog, text="Questions (min 2, max 10):", font=('Arial', 10, 'bold')).pack(anchor=tk.W, padx=10, pady=5)
        
        questions_container = tk.Frame(scrollable_dialog)
        questions_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        question_entries = []
        
        def add_question_field():
            if len(question_entries) >= 10:
                messagebox.showwarning("Limit", "Maximum 10 questions per group")
                return
            
            q_frame = tk.LabelFrame(questions_container, text=f"Question {len(question_entries)+1}", 
                                   font=('Arial', 9, 'bold'), padx=5, pady=5)
            q_frame.pack(fill=tk.X, pady=5)
            
            # Question text
            tk.Label(q_frame, text="Question Text:").pack(anchor=tk.W, padx=5)
            q_text = tk.Entry(q_frame, width=80)
            q_text.pack(fill=tk.X, padx=5, pady=2)
            
            question_data = {'text': q_text, 'frame': q_frame}
            
            # Get current question type
            current_type = type_var.get()
            
            # Type 1: Multiple choice - need choices
            if current_type == QuestionType.TYPE1.value:
                tk.Label(q_frame, text="Choices (one per line):").pack(anchor=tk.W, padx=5, pady=2)
                choices_text = scrolledtext.ScrolledText(q_frame, height=4, width=70)
                choices_text.pack(fill=tk.X, padx=5, pady=2)
                choices_text.insert("1.0", "A. Choice one\nB. Choice two\nC. Choice three\nD. Choice four")
                question_data['choices'] = choices_text
                
                tk.Label(q_frame, text="Correct Answer (A, B, C, or D):").pack(anchor=tk.W, padx=5)
                q_answer = tk.Entry(q_frame, width=20)
                q_answer.pack(anchor=tk.W, padx=5, pady=2)
                question_data['answer'] = q_answer
            
            # Types 2 & 3: True/False/Not Given or Yes/No/Not Given
            elif current_type in [QuestionType.TYPE2.value, QuestionType.TYPE3.value]:
                answer_options = ['TRUE', 'FALSE', 'NOT GIVEN'] if current_type == QuestionType.TYPE2.value else ['YES', 'NO', 'NOT GIVEN']
                tk.Label(q_frame, text=f"Correct Answer ({'/'.join(answer_options)}):").pack(anchor=tk.W, padx=5)
                answer_var = tk.StringVar(value=answer_options[0])
                answer_combo = ttk.Combobox(q_frame, textvariable=answer_var, values=answer_options, 
                                           width=20, state='readonly')
                answer_combo.pack(anchor=tk.W, padx=5, pady=2)
                question_data['answer'] = answer_var
            
            # Types 4-7: Matching types - answer is letter/number
            elif current_type in [QuestionType.TYPE4.value, QuestionType.TYPE5.value, 
                                 QuestionType.TYPE6.value, QuestionType.TYPE7.value]:
                tk.Label(q_frame, text="Correct Answer (letter or number from the list):").pack(anchor=tk.W, padx=5)
                q_answer = tk.Entry(q_frame, width=20)
                q_answer.pack(anchor=tk.W, padx=5, pady=2)
                question_data['answer'] = q_answer
            
            # Types 8, 9, 10, 11: Text answer
            else:
                tk.Label(q_frame, text="Correct Answer:").pack(anchor=tk.W, padx=5)
                q_answer = tk.Entry(q_frame, width=60)
                q_answer.pack(anchor=tk.W, padx=5, pady=2)
                question_data['answer'] = q_answer
            
            # Remove button
            def remove_this_question():
                question_entries.remove(question_data)
                q_frame.destroy()
            
            tk.Button(q_frame, text="Remove Question", command=remove_this_question, 
                     bg='#e74c3c', fg='white').pack(anchor=tk.E, padx=5, pady=5)
            
            question_entries.append(question_data)
        
        # Add question button
        btn_frame = tk.Frame(scrollable_dialog)
        btn_frame.pack(fill=tk.X, padx=10, pady=5)
        
        tk.Button(btn_frame, text="+ Add Question", command=add_question_field,
                 bg='#3498db', fg='white', font=('Arial', 10)).pack(side=tk.LEFT, padx=5)
        
        # Add initial question fields
        for _ in range(2):
            add_question_field()
        
        # Save button
        def save_group():
            # Validate
            if len(question_entries) < 2:
                messagebox.showerror("Error", "Minimum 2 questions required")
                return
            
            # Create question group
            qg = QuestionGroup()
            qg.explanation = explanation_editor.get_text()
            
            # Set type
            for qt in QuestionType:
                if qt.value == type_var.get():
                    qg.type = qt
                    break
            
            # Collect additional inputs
            additional_data = {}
            for key, widget in additional_widgets.items():
                if key == 'type9_mode':
                    continue  # Skip mode indicator
                elif key == 'type9_selector':
                    continue  # Skip selector
                elif key == 'tableData':
                    # Extract table data
                    table_info = widget
                    rows = int(table_info['rows'].get())
                    cols = int(table_info['cols'].get())
                    
                    table_content = []
                    for r in range(rows):
                        row_data = []
                        for c in range(cols):
                            cell = table_info['cells'].get(f"{r},{c}")
                            if cell:
                                row_data.append(cell.get())
                            else:
                                row_data.append("")
                        table_content.append(row_data)
                    
                    additional_data['tableData'] = {
                        'rows': rows,
                        'cols': cols,
                        'content': table_content
                    }
                elif key == 'flowchartData':
                    content = widget.get("1.0", "end-1c").strip()
                    if content:
                        additional_data['flowchartData'] = content
                elif isinstance(widget, scrolledtext.ScrolledText):
                    content = widget.get("1.0", "end-1c").strip()
                    if content:
                        if key in ['infoList', 'headingList', 'featureList', 'sentenceEndingList']:
                            # Split by lines for lists
                            additional_data[key] = [line.strip() for line in content.split('\n') if line.strip()]
                        else:
                            additional_data[key] = content
            
            if additional_data:
                qg.additional_inputs = AdditionalInput(input_type=qg.type.value, data=additional_data)
            
            # Add questions
            for i, qe in enumerate(question_entries):
                q = Question()
                q.question_id = f"{self.current_package.package_id}_qg{len(self.current_package.question_groups)}_q{i}"
                q.text = qe['text'].get().strip()
                
                if not q.text:
                    continue
                
                # Get answer based on type
                if 'choices' in qe:
                    # Type 1: Store choices in question text or additional data
                    choices = qe['choices'].get("1.0", "end-1c").strip()
                    q.text = f"{q.text}\n{choices}"
                    answer_widget = qe['answer']
                    q.answer = answer_widget.get().strip().upper() if isinstance(answer_widget, tk.Entry) else answer_widget.get()
                elif isinstance(qe['answer'], tk.StringVar):
                    q.answer = qe['answer'].get()
                else:
                    q.answer = qe['answer'].get().strip()
                
                if q.text and q.answer:
                    qg.questions.append(q)
            
            if not qg.validate():
                messagebox.showerror("Error", "Question group must have 2-10 valid questions with answers")
                return
            
            self.current_package.question_groups.append(qg)
            self.status_bar.config(text=f"Question group added. Total groups: {len(self.current_package.question_groups)}")
            messagebox.showinfo("Success", f"Question group added successfully!\nTotal questions: {len(qg.questions)}")
            dialog.destroy()
        
        save_btn = tk.Button(scrollable_dialog, text="Save Question Group", command=save_group, 
                            bg='#27ae60', fg='white', font=('Arial', 12, 'bold'), width=20, height=2)
        save_btn.pack(pady=15)
        
        # Pack canvas and scrollbar
        main_canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
    
    def view_question_groups(self):
        """View all question groups"""
        dialog = tk.Toplevel(self.root)
        dialog.title("Question Groups")
        dialog.geometry("800x600")
        
        text = scrolledtext.ScrolledText(dialog, wrap=tk.WORD)
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        if not self.current_package.question_groups:
            text.insert("1.0", "No question groups added yet.")
        else:
            for i, qg in enumerate(self.current_package.question_groups):
                text.insert("end", f"\n{'='*60}\n")
                text.insert("end", f"Question Group {i+1}\n")
                text.insert("end", f"{'='*60}\n")
                text.insert("end", f"Type: {qg.type.value}\n")
                text.insert("end", f"Explanation: {qg.explanation}\n")
                text.insert("end", f"Number of questions: {len(qg.questions)}\n\n")
                
                for j, q in enumerate(qg.questions):
                    text.insert("end", f"Q{j+1}: {q.text}\n")
                    text.insert("end", f"Answer: {q.answer}\n\n")
        
        text.config(state=tk.DISABLED)
    
    def new_package(self):
        """Create new package"""
        if messagebox.askyesno("New Package", "Create a new package? Unsaved changes will be lost."):
            self.current_package = ReadingPackage()
            self.current_package.package_id = str(uuid.uuid4())
            
            # Clear editors
            self.explanation_editor.clear()
            self.title_editor.clear()
            for para in self.paragraph_editors:
                para['container'].destroy()
            self.paragraph_editors = []
            
            self.status_bar.config(text="New package created")
    
    def save_package(self):
        """Save package to file"""
        if not self.current_package.reading_content.title:
            messagebox.showerror("Error", "Please add reading content first")
            return
        
        if not self.current_package.question_groups:
            messagebox.showerror("Error", "Please add at least one question group")
            return
        
        filepath = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        
        if filepath:
            try:
                self.current_package.save_to_file(filepath)
                self.status_bar.config(text=f"Package saved: {filepath}")
                messagebox.showinfo("Success", f"Package saved successfully to:\n{filepath}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save package:\n{str(e)}")
    
    def open_package(self):
        """Open existing package"""
        filepath = filedialog.askopenfilename(
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        
        if filepath:
            try:
                self.current_package = ReadingPackage.load_from_file(filepath)
                
                # Load reading content
                self.explanation_editor.set_text(self.current_package.reading_content.explanation)
                self.title_editor.set_text(self.current_package.reading_content.title)
                
                # Clear existing paragraphs
                for para in self.paragraph_editors:
                    para['container'].destroy()
                self.paragraph_editors = []
                
                # Load paragraphs
                for para in self.current_package.reading_content.paragraphs:
                    self.add_paragraph()
                    self.paragraph_editors[-1]['title'].set_text(para.title)
                    self.paragraph_editors[-1]['body'].set_text(para.body)
                
                self.status_bar.config(text=f"Package loaded: {filepath}")
                messagebox.showinfo("Success", "Package loaded successfully!")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load package:\n{str(e)}")


def main():
    root = tk.Tk()
    app = ContentEditorWindow(root)
    root.mainloop()


if __name__ == "__main__":
    main()

====================================================================================================
FILE: exam_engine.py
====================================================================================================

"""
Exam Engine Module
Load a saved reading package and present it in an interactive exam environment
"""
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
from typing import Dict, List, Optional
from datetime import datetime, timedelta
import threading
import re
import os
from models import (
    ReadingPackage, AnswerRecord, HighlightRecord, QuestionType
)


class HighlightToolbar(tk.Frame):
    """Toolbar for text highlighting"""
    
    def __init__(self, parent, callback):
        super().__init__(parent, bg='lightgray', relief=tk.RAISED, bd=2)
        self.callback = callback
        
        colors = [
            ('Yellow', '#FFFF00'),
            ('Green', '#90EE90'),
            ('Blue', '#ADD8E6'),
            ('Pink', '#FFB6C1')
        ]
        
        for color_name, color_code in colors:
            btn = tk.Button(self, text=color_name, bg=color_code, 
                          command=lambda c=color_code: self.callback(c))
            btn.pack(side=tk.LEFT, padx=2)
        
        tk.Button(self, text="Remove", command=lambda: self.callback(None)).pack(side=tk.LEFT, padx=2)


class ExamEngineWindow:
    """Main Exam Engine Window"""
    
    def __init__(self, root, package_path: Optional[str] = None):
        self.root = root
        self.root.title("IELTS Reading Exam")
        
        # Make fullscreen
        self.root.state('zoomed')  # Windows/Linux
        try:
            self.root.attributes('-zoomed', True)  # Alternative for some systems
        except:
            pass
        
        # Get screen dimensions
        self.screen_width = self.root.winfo_screenwidth()
        self.screen_height = self.root.winfo_screenheight()
        
        # Set minimum size
        self.root.minsize(1024, 768)
        
        self.package: Optional[ReadingPackage] = None
        self.answer_records: Dict[str, AnswerRecord] = {}
        self.highlight_records: List[HighlightRecord] = []
        
        # Timer variables
        self.exam_duration = 60 * 60  # 60 minutes in seconds
        self.time_remaining = self.exam_duration
        self.timer_running = False
        self.exam_started = False
        
        # Answer widgets
        self.answer_widgets: Dict[str, tk.Widget] = {}
        self._diagram_images: List[tk.PhotoImage] = []
        
        if package_path:
            self.load_package(package_path)
        else:
            self.prompt_load_package()
    
    def prompt_load_package(self):
        """Prompt user to load a package"""
        filepath = filedialog.askopenfilename(
            title="Select Reading Package",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        
        if filepath:
            self.load_package(filepath)
        else:
            messagebox.showwarning("No Package", "No package selected. Please load a package.")
            self.root.after(100, self.prompt_load_package)
    
    def load_package(self, filepath: str):
        """Load reading package from file"""
        try:
            self.package = ReadingPackage.load_from_file(filepath)
            self.create_ui()
            messagebox.showinfo("Package Loaded", 
                              f"Package loaded successfully!\n\n"
                              f"Title: {self.package.reading_content.title}\n"
                              f"Question Groups: {len(self.package.question_groups)}\n"
                              f"Total Questions: {sum(len(qg.questions) for qg in self.package.question_groups)}\n\n"
                              f"Click 'Start Exam' to begin.")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load package:\n{str(e)}")
            self.root.quit()
    
    def create_ui(self):
        """Create the exam UI"""
        # Top bar
        top_bar = tk.Frame(self.root, bg='#2c3e50', height=60)
        top_bar.pack(fill=tk.X, side=tk.TOP)
        top_bar.pack_propagate(False)
        
        # Timer display
        timer_frame = tk.Frame(top_bar, bg='#2c3e50')
        timer_frame.pack(side=tk.LEFT, padx=20)
        
        tk.Label(timer_frame, text="Time Remaining:", bg='#2c3e50', 
                fg='white', font=('Arial', 12)).pack()
        self.timer_label = tk.Label(timer_frame, text="60:00", bg='#2c3e50',
                                    fg='#e74c3c', font=('Arial', 24, 'bold'))
        self.timer_label.pack()
        
        # Control buttons
        button_frame = tk.Frame(top_bar, bg='#2c3e50')
        button_frame.pack(side=tk.RIGHT, padx=20)
        
        self.start_btn = tk.Button(button_frame, text="Start Exam", 
                                   command=self.start_exam, bg='#27ae60', fg='white',
                                   font=('Arial', 12, 'bold'), width=12)
        self.start_btn.pack(side=tk.LEFT, padx=5)
        
        self.pause_btn = tk.Button(button_frame, text="Pause", 
                                   command=self.pause_exam, bg='#f39c12', fg='white',
                                   font=('Arial', 12, 'bold'), width=12, state=tk.DISABLED)
        self.pause_btn.pack(side=tk.LEFT, padx=5)
        
        self.end_btn = tk.Button(button_frame, text="End Exam", 
                                command=self.end_exam, bg='#e74c3c', fg='white',
                                font=('Arial', 12, 'bold'), width=12, state=tk.DISABLED)
        self.end_btn.pack(side=tk.LEFT, padx=5)
        
        # Main split screen
        paned = tk.PanedWindow(self.root, orient=tk.HORIZONTAL)
        paned.pack(fill=tk.BOTH, expand=True)
        
        # Left pane - Reading content
        left_frame = tk.Frame(paned)
        paned.add(left_frame, width=700)
        
        tk.Label(left_frame, text="Reading Passage", font=('Arial', 14, 'bold'),
                bg='#34495e', fg='white').pack(fill=tk.X)
        
        self.reading_text = scrolledtext.ScrolledText(left_frame, wrap=tk.WORD, 
                                                      font=('Arial', 12), padx=20, pady=15,
                                                      spacing1=3, spacing2=2, spacing3=3)
        self.reading_text.pack(fill=tk.BOTH, expand=True)
        
        # Bind selection event for highlighting
        self.reading_text.bind("<<Selection>>", self.on_text_selection)
        
        # Configure highlight tags
        self.reading_text.tag_configure('highlight_yellow', background='#FFFF00')
        self.reading_text.tag_configure('highlight_green', background='#90EE90')
        self.reading_text.tag_configure('highlight_blue', background='#ADD8E6')
        self.reading_text.tag_configure('highlight_pink', background='#FFB6C1')
        
        # Right pane - Questions
        right_frame = tk.Frame(paned)
        paned.add(right_frame, width=700)
        
        tk.Label(right_frame, text="Questions", font=('Arial', 14, 'bold'),
                bg='#34495e', fg='white').pack(fill=tk.X)
        
        # Canvas with scrollbar for questions
        canvas = tk.Canvas(right_frame)
        scrollbar = ttk.Scrollbar(right_frame, orient="vertical", command=canvas.yview)
        self.questions_frame = tk.Frame(canvas)
        
        self.questions_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=self.questions_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # Enable mouse wheel scrolling in the question panel
        self.bind_mousewheel_scrolling(canvas)
        
        # Load content
        self.load_reading_content()
        self.load_questions()
        
        # Highlight toolbar (initially hidden)
        self.highlight_toolbar = None

    def bind_mousewheel_scrolling(self, widget):
        """Enable cross-platform mouse-wheel scrolling for canvas/text widgets."""
        def _on_mousewheel(event):
            if hasattr(event, "delta") and event.delta:
                widget.yview_scroll(int(-1 * (event.delta / 120)), "units")
            elif event.num == 4:
                widget.yview_scroll(-1, "units")
            elif event.num == 5:
                widget.yview_scroll(1, "units")

        widget.bind_all("<MouseWheel>", _on_mousewheel, add="+")
        widget.bind_all("<Button-4>", _on_mousewheel, add="+")
        widget.bind_all("<Button-5>", _on_mousewheel, add="+")
    
    def load_reading_content(self):
        """Load reading content into left pane"""
        self.reading_text.config(state=tk.NORMAL)
        self.reading_text.delete("1.0", "end")
        
        rc = self.package.reading_content
        
        # Explanation
        if rc.explanation:
            self.reading_text.insert("end", rc.explanation + "\n\n", 'explanation')
            self.reading_text.tag_configure('explanation', font=('Arial', 11, 'italic'), 
                                           foreground='#555555')
        
        # Title
        if rc.title:
            self.reading_text.insert("end", rc.title + "\n\n", 'title')
            self.reading_text.tag_configure('title', font=('Arial', 18, 'bold'), 
                                           justify='center', spacing3=10)
        
        # Paragraphs
        for i, para in enumerate(rc.paragraphs):
            if para.title:
                self.reading_text.insert("end", f"{para.title}\n", f'para_title_{i}')
                self.reading_text.tag_configure(f'para_title_{i}', font=('Arial', 14, 'bold'),
                                               spacing1=10, spacing3=5)
            
            if para.body:
                self.reading_text.insert("end", f"{para.body}\n\n", f'para_body_{i}')
                self.reading_text.tag_configure(f'para_body_{i}', font=('Arial', 12),
                                               spacing1=2, spacing2=2, spacing3=5)
        
        self.reading_text.config(state=tk.DISABLED)
    
    def load_questions(self):
        """Load questions into right pane"""
        question_number = 1
        
        for group_idx, qg in enumerate(self.package.question_groups):
            # Group frame
            group_frame = tk.LabelFrame(self.questions_frame, 
                                       text=f"Questions {question_number}-{question_number + len(qg.questions) - 1}",
                                       font=('Arial', 12, 'bold'), padx=10, pady=10)
            group_frame.pack(fill=tk.X, padx=10, pady=10)
            
            # Explanation
            if qg.explanation:
                tk.Label(group_frame, text=qg.explanation, wraplength=600, 
                        justify=tk.LEFT, font=('Arial', 10, 'italic')).pack(anchor=tk.W, pady=5)
            
            # Type indicator
            tk.Label(group_frame, text=f"Type: {qg.type.value}", 
                    font=('Arial', 10), fg='blue').pack(anchor=tk.W, pady=5)
            
            # Additional inputs (if any) - display and collect options for dropdowns
            matching_options = []
            if qg.additional_inputs:
                matching_options = self.render_additional_inputs(group_frame, qg.additional_inputs)
            
            # Questions
            for q in qg.questions:
                q_frame = tk.Frame(group_frame)
                q_frame.pack(fill=tk.X, pady=5)
                
                # Extract question text (without choices for Type 1)
                question_display = q.text
                if qg.type == QuestionType.TYPE1 and '\n' in q.text:
                    question_display = q.text.split('\n')[0]
                
                tk.Label(q_frame, text=f"{question_number}. {question_display}", 
                        wraplength=500, justify=tk.LEFT, font=('Arial', 10)).pack(anchor=tk.W)
                
                # Answer input based on question type
                answer_widget = self.create_answer_input(q_frame, qg.type, q.question_id, q.text)
                
                # For matching types, populate dropdown with options
                if qg.type in [QuestionType.TYPE4, QuestionType.TYPE5, 
                              QuestionType.TYPE6, QuestionType.TYPE7] and matching_options:
                    if isinstance(answer_widget, tk.StringVar):
                        # Find the combobox widget
                        for widget in q_frame.winfo_children():
                            if isinstance(widget, ttk.Combobox):
                                widget['values'] = matching_options
                                break
                
                self.answer_widgets[q.question_id] = answer_widget
                
                # Initialize answer record
                self.answer_records[q.question_id] = AnswerRecord(question_id=q.question_id)
                
                question_number += 1
    
    def create_answer_input(self, parent, question_type: QuestionType, question_id: str, question_text: str = "") -> tk.Widget:
        """Create appropriate answer input widget based on question type"""
        if question_type == QuestionType.TYPE1:  # Multiple choice
            var = tk.StringVar()
            frame = tk.Frame(parent)
            frame.pack(anchor=tk.W, padx=20, pady=5)
            
            # Extract choices from question text if embedded
            choices = ['A', 'B', 'C', 'D']  # Default
            if '\n' in question_text:
                lines = question_text.split('\n')
                choice_lines = [line for line in lines[1:] if line.strip() and (line.strip()[0] in ['A', 'B', 'C', 'D', 'a', 'b', 'c', 'd'])]
                if choice_lines:
                    for line in choice_lines:
                        parts = line.split('.', 1)
                        if len(parts) >= 2:
                            option = parts[0].strip().upper()
                            text = parts[1].strip()
                            tk.Radiobutton(frame, text=f"{option}. {text}", variable=var, value=option,
                                         command=lambda: self.record_answer(question_id, var.get()),
                                         wraplength=500, justify=tk.LEFT).pack(anchor=tk.W, pady=2)
                else:
                    # Fallback to default options
                    for option in choices:
                        tk.Radiobutton(frame, text=option, variable=var, value=option,
                                     command=lambda: self.record_answer(question_id, var.get())).pack(anchor=tk.W)
            else:
                for option in choices:
                    tk.Radiobutton(frame, text=option, variable=var, value=option,
                                 command=lambda: self.record_answer(question_id, var.get())).pack(anchor=tk.W)
            return var
        
        elif question_type in [QuestionType.TYPE2, QuestionType.TYPE3]:  # True/False/Not Given or Yes/No/Not Given
            var = tk.StringVar()
            frame = tk.Frame(parent)
            frame.pack(anchor=tk.W, padx=20, pady=5)
            
            options = ['TRUE', 'FALSE', 'NOT GIVEN'] if question_type == QuestionType.TYPE2 else ['YES', 'NO', 'NOT GIVEN']
            for option in options:
                tk.Radiobutton(frame, text=option, variable=var, value=option,
                             command=lambda: self.record_answer(question_id, var.get())).pack(anchor=tk.W)
            return var
        
        elif question_type in [QuestionType.TYPE4, QuestionType.TYPE5, 
                              QuestionType.TYPE6, QuestionType.TYPE7]:  # Matching types
            var = tk.StringVar()
            combo = ttk.Combobox(parent, textvariable=var, width=30, state='readonly')
            combo.pack(anchor=tk.W, padx=20, pady=5)
            combo.bind('<<ComboboxSelected>>', lambda e: self.record_answer(question_id, var.get()))
            return var
        
        else:  # Text input for other types (8, 9, 10, 11)
            var = tk.StringVar()
            entry = tk.Entry(parent, textvariable=var, width=40)
            entry.pack(anchor=tk.W, padx=20, pady=5)
            entry.bind('<KeyRelease>', lambda e: self.record_answer(question_id, var.get()))
            return var
    
    def render_additional_inputs(self, parent, additional_inputs):
        """Render additional inputs like lists, tables, etc. and return options for dropdowns"""
        frame = tk.LabelFrame(parent, text="üìã ADDITIONAL INFORMATION - READ CAREFULLY", 
                             padx=15, pady=15, font=('Arial', 11, 'bold'),
                             bg='#fff9e6', relief=tk.SOLID, bd=2)
        frame.pack(fill=tk.X, pady=10)
        
        data = additional_inputs.data
        options = []
        
        # Render based on data type
        if 'infoList' in data:
            tk.Label(frame, text="Match the information to the correct option:", 
                    font=('Arial', 10, 'bold'), bg='#fff9e6').pack(anchor=tk.W, pady=5)
            
            list_frame = tk.Frame(frame, bg='white', relief=tk.RIDGE, bd=2)
            list_frame.pack(fill=tk.X, padx=5, pady=5)
            
            for item in data['infoList']:
                tk.Label(list_frame, text=f"  {item}", justify=tk.LEFT, 
                        wraplength=600, font=('Arial', 10), bg='white',
                        pady=3).pack(anchor=tk.W, padx=10, pady=2)
                options.append(item.split('.')[0].strip() if '.' in item else item[:10])
        
        elif 'headingList' in data:
            tk.Label(frame, text="Choose the correct heading:", 
                    font=('Arial', 10, 'bold'), bg='#fff9e6').pack(anchor=tk.W, pady=5)
            
            list_frame = tk.Frame(frame, bg='white', relief=tk.RIDGE, bd=2)
            list_frame.pack(fill=tk.X, padx=5, pady=5)
            
            for i, heading in enumerate(data['headingList']):
                tk.Label(list_frame, text=f"  {heading}", justify=tk.LEFT, 
                        wraplength=600, font=('Arial', 10), bg='white',
                        pady=3).pack(anchor=tk.W, padx=10, pady=2)
                options.append(heading.split('.')[0].strip() if '.' in heading else heading[:20])
        
        elif 'featureList' in data:
            tk.Label(frame, text="Match features to the options:", 
                    font=('Arial', 10, 'bold'), bg='#fff9e6').pack(anchor=tk.W, pady=5)
            
            list_frame = tk.Frame(frame, bg='white', relief=tk.RIDGE, bd=2)
            list_frame.pack(fill=tk.X, padx=5, pady=5)
            
            for item in data['featureList']:
                tk.Label(list_frame, text=f"  {item}", justify=tk.LEFT, 
                        wraplength=600, font=('Arial', 10), bg='white',
                        pady=3).pack(anchor=tk.W, padx=10, pady=2)
                options.append(item.split('.')[0].strip() if '.' in item else item[:15])
        
        elif 'sentenceEndingList' in data:
            tk.Label(frame, text="Complete the sentences with the correct ending:", 
                    font=('Arial', 10, 'bold'), bg='#fff9e6').pack(anchor=tk.W, pady=5)
            
            list_frame = tk.Frame(frame, bg='white', relief=tk.RIDGE, bd=2)
            list_frame.pack(fill=tk.X, padx=5, pady=5)
            
            for i, ending in enumerate(data['sentenceEndingList']):
                tk.Label(list_frame, text=f"  {ending}", justify=tk.LEFT, 
                        wraplength=600, font=('Arial', 10), bg='white',
                        pady=3).pack(anchor=tk.W, padx=10, pady=2)
                options.append(ending.split('.')[0].strip() if '.' in ending else chr(65+i))
        
        elif 'summaryData' in data:
            tk.Label(frame, text="üìù SUMMARY - Complete the gaps below:", 
                    font=('Arial', 10, 'bold'), bg='#fff9e6', fg='#d35400').pack(anchor=tk.W, pady=5)
            
            summary_frame = tk.Frame(frame, bg='white', relief=tk.SOLID, bd=2)
            summary_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            text_widget = scrolledtext.ScrolledText(summary_frame, height=8, width=70, 
                                                   wrap=tk.WORD, font=('Arial', 11),
                                                   bg='#fffef0', relief=tk.FLAT, padx=10, pady=10)
            text_widget.pack(fill=tk.BOTH, expand=True)
            text_widget.insert("1.0", data['summaryData'])
            
            # Configure highlight tags
            text_widget.tag_configure('highlight_yellow', background='#FFFF00')
            text_widget.tag_configure('highlight_green', background='#90EE90')
            text_widget.tag_configure('highlight_blue', background='#ADD8E6')
            text_widget.tag_configure('highlight_pink', background='#FFB6C1')
            text_widget.tag_configure('blank', background='#ffeb3b', font=('Arial', 11, 'bold'))
            
            # Highlight blanks
            content = data['summaryData']
            for match in re.finditer(r'\[\d+\]|\[BLANK\]', content):
                start_idx = f"1.0+{match.start()}c"
                end_idx = f"1.0+{match.end()}c"
                text_widget.tag_add('blank', start_idx, end_idx)
            
            # Enable text selection and bind highlighting
            text_widget.bind("<<Selection>>", lambda e: self.show_highlight_menu(e, text_widget))
            self.bind_mousewheel_scrolling(text_widget)
        
        elif 'tableData' in data:
            tk.Label(frame, text="üìä TABLE - Complete the gaps below:", 
                    font=('Arial', 10, 'bold'), bg='#fff9e6', fg='#d35400').pack(anchor=tk.W, pady=5)
            
            # Create a canvas for the table with selection capability
            table_container = tk.Frame(frame, bg='white', relief=tk.SOLID, bd=2)
            table_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            table_canvas = tk.Canvas(table_container, bg='white', height=300)
            table_scrollbar = ttk.Scrollbar(table_container, orient="vertical", command=table_canvas.yview)
            table_inner = tk.Frame(table_canvas, bg='white')
            
            table_inner.bind("<Configure>", lambda e: table_canvas.configure(scrollregion=table_canvas.bbox("all")))
            table_canvas.create_window((0, 0), window=table_inner, anchor="nw")
            table_canvas.configure(yscrollcommand=table_scrollbar.set)
            
            # Display table with Text widgets for highlighting support
            table_data = data['tableData']
            rows = table_data['rows']
            cols = table_data['cols']
            content = table_data['content']
            
            for r in range(rows):
                for c in range(cols):
                    cell_text = content[r][c] if r < len(content) and c < len(content[r]) else ""
                    
                    # Determine if this cell contains a blank
                    is_blank = '[BLANK]' in cell_text or bool(re.search(r'\[\d+\]', cell_text))
                    is_header = (r == 0)
                    
                    # Use Text widget instead of Label to support highlighting
                    cell_widget = tk.Text(table_inner, width=18, height=3, 
                                         relief=tk.SOLID, bd=1, wrap=tk.WORD,
                                         font=('Arial', 10, 'bold' if is_header else 'normal'),
                                         padx=5, pady=5)
                    
                    # Set background color
                    if is_blank:
                        cell_widget.configure(bg='#ffeb3b')
                    elif is_header:
                        cell_widget.configure(bg='#e8e8e8')
                    else:
                        cell_widget.configure(bg='white')
                    
                    cell_widget.insert("1.0", cell_text)
                    cell_widget.configure(state=tk.DISABLED)  # Make read-only but selectable
                    
                    # Configure highlight tags
                    cell_widget.tag_configure('highlight_yellow', background='#FFFF00')
                    cell_widget.tag_configure('highlight_green', background='#90EE90')
                    cell_widget.tag_configure('highlight_blue', background='#ADD8E6')
                    cell_widget.tag_configure('highlight_pink', background='#FFB6C1')
                    
                    # Enable highlighting
                    cell_widget.bind("<<Selection>>", lambda e, w=cell_widget: self.show_highlight_menu(e, w))
                    
                    cell_widget.grid(row=r, column=c, sticky='nsew', padx=1, pady=1)
            
            # Configure column weights
            for c in range(cols):
                table_inner.columnconfigure(c, weight=1)
            
            table_canvas.pack(side="left", fill="both", expand=True, padx=10, pady=10)
            table_scrollbar.pack(side="right", fill="y")
            self.bind_mousewheel_scrolling(table_canvas)
        
        elif 'flowchartData' in data:
            tk.Label(frame, text="üîÑ FLOW-CHART - Complete the gaps below:", 
                    font=('Arial', 10, 'bold'), bg='#fff9e6', fg='#d35400').pack(anchor=tk.W, pady=5)
            
            # Create canvas for graphical flowchart
            flowchart_container = tk.Frame(frame, bg='white', relief=tk.SOLID, bd=2)
            flowchart_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            # Use canvas to draw flowchart graphically
            canvas = tk.Canvas(flowchart_container, bg='white', height=400, width=650)
            scrollbar_y = ttk.Scrollbar(flowchart_container, orient="vertical", command=canvas.yview)
            scrollbar_x = ttk.Scrollbar(flowchart_container, orient="horizontal", command=canvas.xview)
            
            canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)
            
            # Parse flowchart data and render graphically
            flowchart_text = data['flowchartData']
            self.render_flowchart_graphically(canvas, flowchart_text)
            
            canvas.pack(side="left", fill="both", expand=True, padx=10, pady=10)
            scrollbar_y.pack(side="right", fill="y")
            scrollbar_x.pack(side="bottom", fill="x")
            self.bind_mousewheel_scrolling(canvas)
            
            # Enable canvas selection for highlighting
            canvas.bind("<Button-1>", lambda e: self.canvas_click_handler(e, canvas))
        
        elif 'diagramImage' in data:
            tk.Label(frame, text="üìê DIAGRAM:", 
                    font=('Arial', 10, 'bold'), bg='#fff9e6', fg='#d35400').pack(anchor=tk.W, pady=5)
            
            diagram_frame = tk.Frame(frame, bg='white', relief=tk.SOLID, bd=2)
            diagram_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            diagram_data = str(data['diagramImage']).strip()

            # If this is an image path, render the image. Otherwise render rich text.
            lower_value = diagram_data.lower()
            is_image_path = (
                os.path.exists(diagram_data)
                and lower_value.endswith((".png", ".gif", ".ppm", ".pgm"))
            )

            if is_image_path:
                image_widget = tk.Label(diagram_frame, bg='white')
                image_widget.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
                try:
                    image = tk.PhotoImage(file=diagram_data)
                    self._diagram_images.append(image)
                    image_widget.config(image=image)
                except tk.TclError:
                    image_widget.config(text=f"Unable to load image: {diagram_data}", font=('Arial', 10), anchor='w')

                tk.Label(
                    diagram_frame,
                    text=f"Image source: {diagram_data}",
                    bg='white',
                    fg='#555555',
                    font=('Arial', 9, 'italic')
                ).pack(anchor=tk.W, padx=10, pady=(0, 8))
            else:
                diagram_text = tk.Text(diagram_frame, height=8, width=70, wrap=tk.WORD,
                                       font=('Arial', 10), bg='white', padx=10, pady=10)
                diagram_text.insert("1.0", diagram_data)
                diagram_text.configure(state=tk.DISABLED)

                # Configure highlight tags
                diagram_text.tag_configure('highlight_yellow', background='#FFFF00')
                diagram_text.tag_configure('highlight_green', background='#90EE90')
                diagram_text.tag_configure('highlight_blue', background='#ADD8E6')
                diagram_text.tag_configure('highlight_pink', background='#FFB6C1')

                # Enable highlighting
                diagram_text.bind("<<Selection>>", lambda e: self.show_highlight_menu(e, diagram_text))
                diagram_text.pack(fill=tk.BOTH, expand=True)
                self.bind_mousewheel_scrolling(diagram_text)
        
        return options
    
    def record_answer(self, question_id: str, answer: str):
        """Record user's answer"""
        if question_id in self.answer_records:
            self.answer_records[question_id].user_answer = answer
            self.answer_records[question_id].timestamp = datetime.now()
    
    def on_text_selection(self, event):
        """Handle text selection for highlighting"""
        if not self.exam_started:
            return
        
        try:
            selection = self.reading_text.get("sel.first", "sel.last")
            if selection and len(selection.strip()) > 0:
                # Show highlight toolbar
                if self.highlight_toolbar:
                    self.highlight_toolbar.destroy()
                
                # Get selection coordinates
                x, y = event.x_root, event.y_root
                
                self.highlight_toolbar = tk.Toplevel(self.root)
                self.highlight_toolbar.wm_overrideredirect(True)
                self.highlight_toolbar.geometry(f"+{x}+{y-30}")
                
                HighlightToolbar(self.highlight_toolbar, self.apply_highlight)
        except tk.TclError:
            pass
    
    def apply_highlight(self, color: Optional[str]):
        """Apply or remove highlight"""
        try:
            start = self.reading_text.index("sel.first")
            end = self.reading_text.index("sel.last")
            
            # Remove existing highlights in range
            for tag in ['highlight_yellow', 'highlight_green', 'highlight_blue', 'highlight_pink']:
                self.reading_text.tag_remove(tag, start, end)
            
            # Apply new highlight
            if color:
                tag_name = f'highlight_{self._color_to_name(color)}'
                self.reading_text.tag_add(tag_name, start, end)
                
                # Record highlight
                record = HighlightRecord(
                    selection_range=f"{start}:{end}",
                    highlight_color=color
                )
                self.highlight_records.append(record)
            
            if self.highlight_toolbar:
                self.highlight_toolbar.destroy()
                self.highlight_toolbar = None
        
        except tk.TclError:
            pass
    
    def _color_to_name(self, color: str) -> str:
        """Convert color code to name"""
        color_map = {
            '#FFFF00': 'yellow',
            '#90EE90': 'green',
            '#ADD8E6': 'blue',
            '#FFB6C1': 'pink'
        }
        return color_map.get(color, 'yellow')
    
    def start_exam(self):
        """Start the exam and timer"""
        if not self.exam_started:
            self.exam_started = True
            self.timer_running = True
            
            self.start_btn.config(state=tk.DISABLED)
            self.pause_btn.config(state=tk.NORMAL)
            self.end_btn.config(state=tk.NORMAL)
            
            # Start timer thread
            self.timer_thread = threading.Thread(target=self.run_timer, daemon=True)
            self.timer_thread.start()
            
            messagebox.showinfo("Exam Started", "The exam has started. Good luck!")
    
    def run_timer(self):
        """Timer countdown"""
        while self.timer_running and self.time_remaining > 0:
            mins, secs = divmod(self.time_remaining, 60)
            self.timer_label.config(text=f"{mins:02d}:{secs:02d}")
            
            # Change color when time is low
            if self.time_remaining <= 300:  # 5 minutes
                self.timer_label.config(fg='#e74c3c')
            elif self.time_remaining <= 600:  # 10 minutes
                self.timer_label.config(fg='#f39c12')
            
            threading.Event().wait(1)
            if self.timer_running:
                self.time_remaining -= 1
        
        if self.time_remaining <= 0:
            self.root.after(0, self.time_up)
    
    def pause_exam(self):
        """Pause/Resume the exam"""
        if self.timer_running:
            self.timer_running = False
            self.pause_btn.config(text="Resume")
            messagebox.showinfo("Paused", "Exam paused")
        else:
            self.timer_running = True
            self.pause_btn.config(text="Pause")
            self.timer_thread = threading.Thread(target=self.run_timer, daemon=True)
            self.timer_thread.start()
    
    def show_highlight_menu(self, event, text_widget):
        """Show highlighting menu for text widgets in tables/flowcharts"""
        try:
            # Check if there's a selection
            text_widget.tag_ranges("sel")
            
            # Create popup menu
            if self.highlight_toolbar:
                self.highlight_toolbar.destroy()
            
            x, y = event.x_root, event.y_root
            
            self.highlight_toolbar = tk.Toplevel(self.root)
            self.highlight_toolbar.wm_overrideredirect(True)
            self.highlight_toolbar.geometry(f"+{x}+{y-30}")
            
            HighlightToolbar(self.highlight_toolbar, lambda color: self.apply_text_highlight(text_widget, color))
        except tk.TclError:
            # No selection
            pass
    
    def apply_text_highlight(self, text_widget, color: Optional[str]):
        """Apply highlight to selected text in a Text widget"""
        try:
            start = text_widget.index("sel.first")
            end = text_widget.index("sel.last")
            
            # Remove existing highlights in range
            for tag in ['highlight_yellow', 'highlight_green', 'highlight_blue', 'highlight_pink']:
                text_widget.tag_remove(tag, start, end)
            
            # Apply new highlight
            if color:
                tag_name = f'highlight_{self._color_to_name(color)}'
                text_widget.tag_add(tag_name, start, end)
            
            if self.highlight_toolbar:
                self.highlight_toolbar.destroy()
                self.highlight_toolbar = None
        except tk.TclError:
            pass
    
    def render_flowchart_graphically(self, canvas, flowchart_text):
        """Render flowchart as graphical elements on canvas"""
        # Simple flowchart parser and renderer
        lines = flowchart_text.split('\n')
        
        y_position = 30
        x_center = 325  # Center of canvas
        box_width = 200
        box_height = 60
        
        # Track elements for connections
        elements = []
        
        for line in lines:
            line = line.strip()
            if not line:
                y_position += 20
                continue
            
            # Detect flowchart elements
            if '‚Üí' in line or '->' in line:
                # Horizontal flow - draw boxes connected by arrows
                parts = re.split(r'[‚Üí->]+', line)
                x_pos = 50
                prev_x = None
                prev_y = None
                
                for part in parts:
                    part = part.strip()
                    if part:
                        # Check if it's a blank
                        is_blank = '[BLANK]' in part or bool(re.search(r'\[\d+\]', part))
                        fill_color = '#ffeb3b' if is_blank else '#e8f4f8'
                        
                        # Draw box
                        canvas.create_rectangle(x_pos, y_position, x_pos + 150, y_position + 50,
                                              fill=fill_color, outline='#2c3e50', width=2)
                        canvas.create_text(x_pos + 75, y_position + 25, text=part,
                                         font=('Arial', 10, 'bold' if is_blank else 'normal'),
                                         width=140)
                        
                        # Draw arrow from previous box
                        if prev_x is not None:
                            canvas.create_line(prev_x + 150, prev_y + 25, x_pos, y_position + 25,
                                             arrow=tk.LAST, width=2, fill='#34495e')
                        
                        prev_x = x_pos
                        prev_y = y_position
                        x_pos += 200
                
                y_position += 80
            
            elif '‚Üì' in line or 'v' in line or '‚Üë' in line:
                # Vertical connector
                y_position += 30
            
            elif line.startswith('Step') or line.startswith('step'):
                # Step box
                is_blank = '[BLANK]' in line or bool(re.search(r'\[\d+\]', line))
                fill_color = '#ffeb3b' if is_blank else '#e8f4f8'
                
                canvas.create_rectangle(x_center - box_width//2, y_position,
                                      x_center + box_width//2, y_position + box_height,
                                      fill=fill_color, outline='#2c3e50', width=2, tags='box')
                canvas.create_text(x_center, y_position + box_height//2, text=line,
                                 font=('Arial', 10, 'bold' if is_blank else 'normal'),
                                 width=box_width - 20, tags='text')
                
                # Draw arrow down
                canvas.create_line(x_center, y_position + box_height,
                                 x_center, y_position + box_height + 30,
                                 arrow=tk.LAST, width=2, fill='#34495e')
                
                y_position += box_height + 40
            
            elif '‚îå' in line or '‚îî' in line or '‚îÇ' in line or '‚îÄ' in line:
                # ASCII box drawing - render as is with Text widget
                text_id = canvas.create_text(x_center, y_position, text=line,
                                            font=('Courier', 9), anchor='n')
                y_position += 15
            
            elif 'Decision' in line or '‚ï±' in line or '‚ï≤' in line:
                # Decision diamond
                is_blank = '[BLANK]' in line or bool(re.search(r'\[\d+\]', line))
                fill_color = '#ffeb3b' if is_blank else '#fff9e6'
                
                # Draw diamond
                points = [
                    x_center, y_position,  # top
                    x_center + 80, y_position + 40,  # right
                    x_center, y_position + 80,  # bottom
                    x_center - 80, y_position + 40  # left
                ]
                canvas.create_polygon(points, fill=fill_color, outline='#2c3e50', width=2)
                
                # Extract text
                text = re.sub(r'[‚ï±‚ï≤\\\/]', '', line).strip()
                canvas.create_text(x_center, y_position + 40, text=text,
                                 font=('Arial', 9, 'bold' if is_blank else 'normal'),
                                 width=120)
                
                y_position += 100
            
            else:
                # Regular text/label
                is_blank = '[BLANK]' in line or bool(re.search(r'\[\d+\]', line))
                fill_color = '#ffeb3b' if is_blank else '#e8f4f8'
                
                canvas.create_rectangle(x_center - box_width//2, y_position,
                                      x_center + box_width//2, y_position + box_height,
                                      fill=fill_color, outline='#2c3e50', width=2)
                canvas.create_text(x_center, y_position + box_height//2, text=line,
                                 font=('Arial', 10, 'bold' if is_blank else 'normal'),
                                 width=box_width - 20)
                
                y_position += box_height + 20
        
        # Update scroll region
        canvas.configure(scrollregion=canvas.bbox("all"))
    
    def canvas_click_handler(self, event, canvas):
        """Handle clicks on canvas for potential future highlighting"""
        # Placeholder for canvas text highlighting if needed
        pass
    
    def time_up(self):
        """Handle time up"""
        self.timer_running = False
        messagebox.showwarning("Time's Up!", "The exam time has ended. Submitting your answers...")
        self.submit_exam()
    
    def end_exam(self):
        """End exam early"""
        if messagebox.askyesno("End Exam", "Are you sure you want to end the exam and submit your answers?"):
            self.timer_running = False
            self.submit_exam()
    
    def submit_exam(self):
        """Submit exam and show results"""
        self.timer_running = False
        self.start_btn.config(state=tk.DISABLED)
        self.pause_btn.config(state=tk.DISABLED)
        self.end_btn.config(state=tk.DISABLED)
        
        # Lock UI
        self.reading_text.config(state=tk.DISABLED)
        for widget in self.answer_widgets.values():
            if isinstance(widget, tk.Entry):
                widget.config(state=tk.DISABLED)
            elif isinstance(widget, ttk.Combobox):
                widget.config(state=tk.DISABLED)
        
        # Open result window
        from result_engine import ResultEngineWindow
        result_window = tk.Toplevel(self.root)
        ResultEngineWindow(result_window, self.package, list(self.answer_records.values()))


def main():
    root = tk.Tk()
    app = ExamEngineWindow(root)
    root.mainloop()


if __name__ == "__main__":
    main()

====================================================================================================
FILE: result_engine.py
====================================================================================================

"""
Result Engine Module
Evaluate user's submitted answers and produce IELTS band score
"""
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
from typing import List, Dict
from models import (
    ReadingPackage, AnswerRecord, EvaluationResult, FeedbackItem,
    IELTSScoringRules
)


class ResultEngineWindow:
    """Result Engine Window for displaying exam results"""
    
    def __init__(self, root, package: ReadingPackage, answer_records: List[AnswerRecord]):
        self.root = root
        self.root.title("IELTS Reading Exam Results")
        self.root.geometry("1000x700")
        
        self.package = package
        self.answer_records = answer_records
        self.evaluation_result: EvaluationResult = None
        
        # Evaluate answers
        self.evaluate()
        
        # Create UI
        self.create_ui()
    
    def evaluate(self):
        """Evaluate user's answers"""
        self.evaluation_result = EvaluationResult()
        
        # Get scoring rules
        scoring_rules = IELTSScoringRules.get_academic_rules()
        
        # Create answer lookup
        answer_lookup: Dict[str, AnswerRecord] = {
            ar.question_id: ar for ar in self.answer_records
        }
        
        # Collect all questions from package
        all_questions = []
        for qg in self.package.question_groups:
            all_questions.extend(qg.questions)
        
        self.evaluation_result.total_questions = len(all_questions)
        
        # Evaluate each question
        for question in all_questions:
            feedback = FeedbackItem(
                question_id=question.question_id,
                is_correct=False,
                correct_answer=question.answer,
                user_answer=None
            )
            
            # Get user's answer
            if question.question_id in answer_lookup:
                user_record = answer_lookup[question.question_id]
                user_answer = user_record.user_answer
                feedback.user_answer = user_answer
                
                if user_answer:
                    # Normalize answers for comparison
                    normalized_user = self.normalize_answer(user_answer)
                    normalized_correct = self.normalize_answer(question.answer)
                    
                    if normalized_user == normalized_correct:
                        feedback.is_correct = True
                        self.evaluation_result.correct_count += 1
                    else:
                        self.evaluation_result.incorrect_count += 1
                else:
                    self.evaluation_result.unanswered_count += 1
            else:
                self.evaluation_result.unanswered_count += 1
            
            self.evaluation_result.per_question_feedback.append(feedback)
        
        # Calculate band score
        correct_count = self.evaluation_result.correct_count
        if correct_count in scoring_rules.mapping:
            self.evaluation_result.band_score = scoring_rules.mapping[correct_count]
        else:
            # Handle edge cases
            max_score = max(scoring_rules.mapping.keys())
            if correct_count > max_score:
                self.evaluation_result.band_score = 9.0
            else:
                self.evaluation_result.band_score = 0.0
    
    def normalize_answer(self, answer: str) -> str:
        """Normalize answer for comparison"""
        if not answer:
            return ""
        
        # Convert to lowercase and strip whitespace
        normalized = answer.lower().strip()
        
        # Remove common punctuation
        for char in ['.', ',', '!', '?', ';', ':']:
            normalized = normalized.replace(char, '')
        
        return normalized
    
    def create_ui(self):
        """Create results UI"""
        # Header
        header = tk.Frame(self.root, bg='#2c3e50', height=80)
        header.pack(fill=tk.X)
        header.pack_propagate(False)
        
        tk.Label(header, text="IELTS Reading Test Results", 
                font=('Arial', 20, 'bold'), bg='#2c3e50', fg='white').pack(pady=20)
        
        # Summary frame
        summary_frame = tk.Frame(self.root, bg='#ecf0f1', pady=20)
        summary_frame.pack(fill=tk.X)
        
        # Create summary cards
        card_frame = tk.Frame(summary_frame, bg='#ecf0f1')
        card_frame.pack()
        
        self.create_summary_card(card_frame, "Band Score", 
                                f"{self.evaluation_result.band_score}", 
                                '#27ae60', 0, 0)
        
        self.create_summary_card(card_frame, "Correct Answers", 
                                f"{self.evaluation_result.correct_count}", 
                                '#3498db', 0, 1)
        
        self.create_summary_card(card_frame, "Incorrect Answers", 
                                f"{self.evaluation_result.incorrect_count}", 
                                '#e74c3c', 0, 2)
        
        self.create_summary_card(card_frame, "Unanswered", 
                                f"{self.evaluation_result.unanswered_count}", 
                                '#95a5a6', 0, 3)
        
        self.create_summary_card(card_frame, "Total Questions", 
                                f"{self.evaluation_result.total_questions}", 
                                '#34495e', 1, 0, colspan=4)
        
        # Band score interpretation
        interpretation = self.get_band_interpretation(self.evaluation_result.band_score)
        tk.Label(summary_frame, text=interpretation, font=('Arial', 11, 'italic'),
                bg='#ecf0f1', fg='#34495e', wraplength=800).pack(pady=10)
        
        # Notebook for detailed results
        notebook = ttk.Notebook(self.root)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Tab 1: Question by Question
        self.create_detailed_tab(notebook)
        
        # Tab 2: Incorrect Answers
        self.create_incorrect_tab(notebook)
        
        # Tab 3: Statistics
        self.create_statistics_tab(notebook)
        
        # Bottom buttons
        button_frame = tk.Frame(self.root)
        button_frame.pack(fill=tk.X, pady=10)
        
        tk.Button(button_frame, text="Export Results", command=self.export_results,
                 bg='#3498db', fg='white', font=('Arial', 11, 'bold'), 
                 width=15).pack(side=tk.LEFT, padx=10)
        
        tk.Button(button_frame, text="Close", command=self.root.destroy,
                 bg='#95a5a6', fg='white', font=('Arial', 11, 'bold'),
                 width=15).pack(side=tk.RIGHT, padx=10)
    
    def create_summary_card(self, parent, title, value, color, row, col, colspan=1):
        """Create a summary card widget"""
        card = tk.Frame(parent, bg=color, width=180, height=100, relief=tk.RAISED, bd=2)
        card.grid(row=row, column=col, padx=10, pady=10, columnspan=colspan, sticky='ew')
        card.grid_propagate(False)
        
        if colspan > 1:
            card.config(width=760)
        
        tk.Label(card, text=title, font=('Arial', 12), bg=color, fg='white').pack(pady=5)
        tk.Label(card, text=value, font=('Arial', 28, 'bold'), bg=color, fg='white').pack()
    
    def get_band_interpretation(self, band_score: float) -> str:
        """Get interpretation of band score"""
        interpretations = {
            9.0: "Expert user - You have fully operational command of the language.",
            8.5: "Very good user - You have fully operational command with occasional inaccuracies.",
            8.0: "Very good user - You handle complex detailed argumentation well.",
            7.5: "Good user - You have operational command with occasional inaccuracies.",
            7.0: "Good user - You have operational command of the language.",
            6.5: "Competent user - Generally effective command despite some inaccuracies.",
            6.0: "Competent user - You have an effective command despite inaccuracies.",
            5.5: "Modest user - You have partial command and can handle overall meaning.",
            5.0: "Modest user - You have partial command of the language.",
            4.5: "Limited user - Basic competence is limited to familiar situations.",
            4.0: "Limited user - You have basic competence in very familiar situations.",
            3.5: "Extremely limited user - You convey meaning in very familiar situations.",
            3.0: "Extremely limited user - You can understand general meaning in familiar contexts.",
            2.5: "Intermittent user - You have great difficulty understanding.",
            2.0: "Intermittent user - You struggle with real communication.",
            1.0: "Non-user - You have no ability to use the language.",
            0.0: "Did not attempt the test."
        }
        
        return interpretations.get(band_score, "Keep practicing to improve your score!")
    
    def create_detailed_tab(self, notebook):
        """Create detailed question-by-question results tab"""
        tab = tk.Frame(notebook)
        notebook.add(tab, text="Detailed Results")
        
        # Create scrolled text
        text = scrolledtext.ScrolledText(tab, wrap=tk.WORD, font=('Courier', 10))
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Add content
        question_num = 1
        for qg_idx, qg in enumerate(self.package.question_groups):
            text.insert("end", f"\n{'='*80}\n", 'header')
            text.insert("end", f"Question Group {qg_idx + 1} - {qg.type.value}\n", 'header')
            text.insert("end", f"{'='*80}\n\n", 'header')
            
            for q in qg.questions:
                # Find feedback for this question
                feedback = next((f for f in self.evaluation_result.per_question_feedback 
                               if f.question_id == q.question_id), None)
                
                if feedback:
                    # Question text
                    text.insert("end", f"Q{question_num}: {q.text}\n", 'question')
                    
                    # User's answer
                    user_ans = feedback.user_answer if feedback.user_answer else "[NOT ANSWERED]"
                    text.insert("end", f"Your Answer: {user_ans}\n", 'user_answer')
                    
                    # Correct answer
                    text.insert("end", f"Correct Answer: {feedback.correct_answer}\n", 'correct_answer')
                    
                    # Result
                    if feedback.is_correct:
                        text.insert("end", "‚úì CORRECT\n\n", 'correct')
                    else:
                        text.insert("end", "‚úó INCORRECT\n\n", 'incorrect')
                
                question_num += 1
        
        # Configure tags
        text.tag_configure('header', font=('Courier', 10, 'bold'))
        text.tag_configure('question', font=('Courier', 10, 'bold'))
        text.tag_configure('correct', foreground='#27ae60', font=('Courier', 10, 'bold'))
        text.tag_configure('incorrect', foreground='#e74c3c', font=('Courier', 10, 'bold'))
        
        text.config(state=tk.DISABLED)
    
    def create_incorrect_tab(self, notebook):
        """Create tab showing only incorrect answers"""
        tab = tk.Frame(notebook)
        notebook.add(tab, text="Incorrect Answers")
        
        # Create scrolled text
        text = scrolledtext.ScrolledText(tab, wrap=tk.WORD, font=('Courier', 10))
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Add content
        incorrect_feedbacks = [f for f in self.evaluation_result.per_question_feedback if not f.is_correct]
        
        if not incorrect_feedbacks:
            text.insert("end", "Congratulations! You answered all questions correctly!\n", 'success')
            text.tag_configure('success', font=('Courier', 12, 'bold'), foreground='#27ae60')
        else:
            text.insert("end", f"Questions you answered incorrectly or left unanswered: {len(incorrect_feedbacks)}\n\n", 'header')
            text.tag_configure('header', font=('Courier', 11, 'bold'))
            
            question_num = 1
            total_questions = 0
            for qg in self.package.question_groups:
                for q in qg.questions:
                    total_questions += 1
                    feedback = next((f for f in incorrect_feedbacks if f.question_id == q.question_id), None)
                    
                    if feedback:
                        text.insert("end", f"\nQuestion {total_questions}:\n", 'question')
                        text.insert("end", f"{q.text}\n", 'question_text')
                        
                        user_ans = feedback.user_answer if feedback.user_answer else "[NOT ANSWERED]"
                        text.insert("end", f"Your Answer: {user_ans}\n", 'user')
                        text.insert("end", f"Correct Answer: {feedback.correct_answer}\n", 'correct')
                        text.insert("end", f"{'-'*60}\n", 'separator')
            
            text.tag_configure('question', font=('Courier', 10, 'bold'))
            text.tag_configure('user', foreground='#e74c3c')
            text.tag_configure('correct', foreground='#27ae60')
        
        text.config(state=tk.DISABLED)
    
    def create_statistics_tab(self, notebook):
        """Create statistics tab"""
        tab = tk.Frame(notebook)
        notebook.add(tab, text="Statistics")
        
        stats_frame = tk.Frame(tab)
        stats_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Overall statistics
        tk.Label(stats_frame, text="Overall Performance", 
                font=('Arial', 16, 'bold')).pack(pady=10)
        
        stats_text = f"""
Total Questions: {self.evaluation_result.total_questions}
Correct Answers: {self.evaluation_result.correct_count}
Incorrect Answers: {self.evaluation_result.incorrect_count}
Unanswered: {self.evaluation_result.unanswered_count}

Accuracy: {(self.evaluation_result.correct_count / self.evaluation_result.total_questions * 100):.1f}%
Completion Rate: {((self.evaluation_result.correct_count + self.evaluation_result.incorrect_count) / self.evaluation_result.total_questions * 100):.1f}%

Band Score: {self.evaluation_result.band_score}
        """
        
        tk.Label(stats_frame, text=stats_text, font=('Courier', 12), 
                justify=tk.LEFT).pack(pady=10)
        
        # Performance by question type
        tk.Label(stats_frame, text="Performance by Question Type", 
                font=('Arial', 14, 'bold')).pack(pady=20)
        
        type_stats = self.calculate_type_statistics()
        
        # Create table
        table_frame = tk.Frame(stats_frame)
        table_frame.pack(pady=10)
        
        headers = ['Question Type', 'Total', 'Correct', 'Accuracy']
        for col, header in enumerate(headers):
            tk.Label(table_frame, text=header, font=('Arial', 11, 'bold'), 
                    width=20, relief=tk.RAISED).grid(row=0, column=col, padx=2, pady=2)
        
        row = 1
        for type_name, stats in type_stats.items():
            tk.Label(table_frame, text=type_name, width=20, 
                    relief=tk.RIDGE).grid(row=row, column=0, padx=2, pady=2)
            tk.Label(table_frame, text=str(stats['total']), width=20, 
                    relief=tk.RIDGE).grid(row=row, column=1, padx=2, pady=2)
            tk.Label(table_frame, text=str(stats['correct']), width=20, 
                    relief=tk.RIDGE).grid(row=row, column=2, padx=2, pady=2)
            
            accuracy = (stats['correct'] / stats['total'] * 100) if stats['total'] > 0 else 0
            tk.Label(table_frame, text=f"{accuracy:.1f}%", width=20, 
                    relief=tk.RIDGE).grid(row=row, column=3, padx=2, pady=2)
            row += 1
    
    def calculate_type_statistics(self) -> Dict:
        """Calculate statistics by question type"""
        stats = {}
        
        for qg in self.package.question_groups:
            type_name = qg.type.value
            if type_name not in stats:
                stats[type_name] = {'total': 0, 'correct': 0}
            
            for q in qg.questions:
                stats[type_name]['total'] += 1
                
                feedback = next((f for f in self.evaluation_result.per_question_feedback 
                               if f.question_id == q.question_id), None)
                
                if feedback and feedback.is_correct:
                    stats[type_name]['correct'] += 1
        
        return stats
    
    def export_results(self):
        """Export results to JSON file"""
        from tkinter import filedialog
        import json
        from datetime import datetime
        
        filepath = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
            initialfile=f"results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        )
        
        if filepath:
            try:
                with open(filepath, 'w', encoding='utf-8') as f:
                    json.dump(self.evaluation_result.to_dict(), f, indent=2, ensure_ascii=False)
                messagebox.showinfo("Success", f"Results exported to:\n{filepath}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to export results:\n{str(e)}")


def main():
    """For testing purposes"""
    root = tk.Tk()
    # This would normally be called from exam_engine
    messagebox.showinfo("Info", "This module should be called from the Exam Engine")
    root.destroy()


if __name__ == "__main__":
    main()

====================================================================================================
FILE: test_installation.py
====================================================================================================

#!/usr/bin/env python3
"""
Test script to verify IELTS Reading Application installation
Run this script to check if all components are working correctly
"""

import sys
import os

def check_python_version():
    """Check if Python version is adequate"""
    print("Checking Python version...")
    version = sys.version_info
    if version.major >= 3 and version.minor >= 7:
        print(f"‚úì Python {version.major}.{version.minor}.{version.micro} - OK")
        return True
    else:
        print(f"‚úó Python {version.major}.{version.minor}.{version.micro} - Need 3.7+")
        return False

def check_tkinter():
    """Check if tkinter is available"""
    print("\nChecking tkinter...")
    try:
        import tkinter as tk
        print("‚úì tkinter is available")
        return True
    except ImportError:
        print("‚úó tkinter is not available")
        print("  Install: sudo apt-get install python3-tk (Linux)")
        print("           or reinstall Python with tcl/tk support")
        return False

def check_modules():
    """Check if all required modules can be imported"""
    print("\nChecking application modules...")
    modules = ['models', 'content_editor', 'exam_engine', 'result_engine', 'main']
    all_ok = True
    
    for module in modules:
        try:
            __import__(module)
            print(f"‚úì {module}.py - OK")
        except ImportError as e:
            print(f"‚úó {module}.py - ERROR: {e}")
            all_ok = False
        except Exception as e:
            print(f"‚ö† {module}.py - WARNING: {e}")
    
    return all_ok

def check_files():
    """Check if all required files exist"""
    print("\nChecking required files...")
    files = [
        'main.py',
        'models.py', 
        'content_editor.py',
        'exam_engine.py',
        'result_engine.py',
        'README.md',
        'requirements.txt',
        'QUICK_START.txt'
    ]
    
    all_ok = True
    for filename in files:
        if os.path.exists(filename):
            print(f"‚úì {filename} - Found")
        else:
            print(f"‚úó {filename} - Missing")
            all_ok = False
    
    return all_ok

def test_data_models():
    """Test basic data model functionality"""
    print("\nTesting data models...")
    try:
        from models import (
            ReadingPackage, ReadingContent, Paragraph,
            QuestionGroup, Question, QuestionType,
            IELTSScoringRules
        )
        
        # Test creating a simple package
        package = ReadingPackage()
        package.package_id = "test_123"
        
        rc = ReadingContent()
        rc.title = "Test Title"
        
        para = Paragraph()
        para.title = "Test Paragraph"
        para.body = "Test content"
        rc.paragraphs.append(para)
        
        package.reading_content = rc
        
        # Test scoring rules
        rules = IELTSScoringRules.get_academic_rules()
        if len(rules.mapping) > 0:
            print("‚úì Data models working correctly")
            return True
        else:
            print("‚úó Scoring rules not loaded")
            return False
            
    except Exception as e:
        print(f"‚úó Data model test failed: {e}")
        return False

def test_package_serialization():
    """Test package save/load functionality"""
    print("\nTesting package serialization...")
    try:
        from models import ReadingPackage, ReadingContent
        import tempfile
        import os
        
        # Create a test package
        package = ReadingPackage()
        package.package_id = "serialize_test"
        package.reading_content = ReadingContent()
        package.reading_content.title = "Serialization Test"
        
        # Save to temporary file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            temp_path = f.name
        
        package.save_to_file(temp_path)
        
        # Load it back
        loaded_package = ReadingPackage.load_from_file(temp_path)
        
        # Clean up
        os.unlink(temp_path)
        
        if loaded_package.package_id == "serialize_test":
            print("‚úì Package serialization working")
            return True
        else:
            print("‚úó Package data mismatch after load")
            return False
            
    except Exception as e:
        print(f"‚úó Serialization test failed: {e}")
        return False

def main():
    """Run all tests"""
    print("="*60)
    print("IELTS Reading Application - Installation Verification")
    print("="*60)
    
    results = []
    
    results.append(("Python Version", check_python_version()))
    results.append(("Tkinter", check_tkinter()))
    results.append(("Files", check_files()))
    results.append(("Modules", check_modules()))
    results.append(("Data Models", test_data_models()))
    results.append(("Serialization", test_package_serialization()))
    
    print("\n" + "="*60)
    print("SUMMARY")
    print("="*60)
    
    all_passed = True
    for test_name, result in results:
        status = "PASS" if result else "FAIL"
        symbol = "‚úì" if result else "‚úó"
        print(f"{symbol} {test_name}: {status}")
        if not result:
            all_passed = False
    
    print("="*60)
    
    if all_passed:
        print("\n‚úì All tests passed! Your installation is ready.")
        print("\nTo start the application, run:")
        print("    python main.py")
    else:
        print("\n‚úó Some tests failed. Please review errors above.")
        print("\nCommon solutions:")
        print("1. Install tkinter: sudo apt-get install python3-tk")
        print("2. Upgrade Python: python3 --version should be 3.7+")
        print("3. Check all files are in the same directory")
    
    print("\n")
    return 0 if all_passed else 1

if __name__ == "__main__":
    sys.exit(main())

